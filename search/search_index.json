{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"RenderKit","text":"<p>A high-performance image and video processor for VFX workflows, built with Python and PySide6.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>OpenImageIO Integration: High-performance, VFX-standard image reading and scaling.</li> <li>Broad Format Support: Native handling of EXR, DPX, TIFF, PNG, and JPEG.</li> <li>Quality-First UI: Intuitive 0-10 Quality Slider using Constant Rate Factor (CRF).</li> <li>H.264 Default + AV1/HEVC Options: Modern codec support with multi-threading optimizations.</li> <li>Smart Sequence Detection: Automatic detection of Houdini, Maya, and generic frame patterns.</li> <li>Modern UI: Dark-themed, studio-grade interface using PySide6.</li> <li>CLI Support: Fully functional command-line interface for headless automation.</li> </ul>"},{"location":"#latest-release","title":"Latest Release","text":"<ul> <li>v0.4.0 (2026-01-09): Preview scales to the panel size with a tighter default footprint, and the Contact Sheet toggle is consolidated into a single control.</li> </ul>"},{"location":"#install","title":"Install","text":""},{"location":"#prebuilt-app","title":"Prebuilt App","text":"<p>/*  * 1. Download the Pre-compiled binaries from the GitHub Releases section  * 2. Unzip the downloaded archive  * 3. Run RenderKit.exe  * 4. Profit!  /</p>"},{"location":"#from-source-uv","title":"From Source (uv)","text":"<pre><code>git clone https://github.com/Ahmed-Hindy/renderkit.git\ncd renderkit\nuv pip install -e .\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#cli","title":"CLI","text":"<pre><code>renderkit convert-exr-sequence render.%04d.exr output.mp4 --fps 24\n</code></pre>"},{"location":"#ui","title":"UI","text":"<pre><code>python -m renderkit.ui.main_window\n</code></pre>"},{"location":"#python-api","title":"Python API","text":"<pre><code>from renderkit import RenderKit\n\nprocessor = RenderKit()\nprocessor.convert_exr_sequence_to_mp4(\n    input_pattern=\"render.%04d.exr\",\n    output_path=\"output.mp4\",\n    fps=24.0\n)\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":"<ul> <li><code>src/</code>: Source code</li> <li><code>tests/</code>: Test suite</li> <li><code>examples/</code>: Usage examples</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome! Please follow these guidelines:</p> <ol> <li>Fork the repository and create a feature branch.</li> <li>Follow code style: The project uses Ruff for formatting and linting.</li> <li>Write tests: Add tests for new features and ensure all tests pass.</li> <li>Type hints: Include type hints for all functions and methods.</li> <li>Update documentation: Keep README and docstrings up to date.</li> </ol>"},{"location":"contributing/#pull-request-workflow","title":"Pull Request Workflow","text":"<ol> <li>Clone your fork.</li> <li> <p>Install dev dependencies:</p> <p><code>bash uv venv uv pip install -e \".[dev]\"</code> 3.  Create a branch. 4.  Make changes. 5.  Verify tests: <code>pytest</code> 6.  Verify linting: <code>ruff check</code> and <code>ruff format</code> 7.  Push and create PR.</p> </li> </ol>"},{"location":"development/","title":"Development","text":""},{"location":"development/#setting-up-development-environment","title":"Setting up Development Environment","text":""},{"location":"development/#using-uv-recommended","title":"Using uv (Recommended)","text":"<pre><code>git clone https://github.com/Ahmed-Hindy/renderkit.git\ncd renderkit\nuv venv\nuv pip install -e \".[dev]\"\n</code></pre>"},{"location":"development/#using-pip","title":"Using pip","text":"<pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"development/#testing","title":"Testing","text":"<p>Run tests with pytest:</p> <pre><code># Run all tests\npython -m pytest tests/ -v\n\n# Run with coverage\npython -m pytest tests/ --cov=renderkit --cov-report=html\n\n# Run only unit tests\npython -m pytest tests/ -v -k \"not test_integration_real_files\"\n\n# Run UI tests (requires pytest-qt and xvfb on Linux)\npython -m pytest tests/test_ui.py -v\n</code></pre>"},{"location":"development/#code-style","title":"Code Style","text":"<p>The project uses: - Ruff for linting and formatting - mypy for type checking</p> <pre><code># Format code\nruff format .\n\n# Lint code\nruff check .\n\n# Type check\nmypy src/\n</code></pre>"},{"location":"development/#build-pyinstaller","title":"Build (PyInstaller)","text":"<pre><code>uv pip install -e . pyinstaller\npython -m PyInstaller --noconfirm RenderKit.spec\n</code></pre> <p>The distributable output is in <code>dist/RenderKit/</code>.</p>"},{"location":"development/#bundled-ffmpeg-windows-hybrid","title":"Bundled FFmpeg (Windows, Hybrid)","text":"<p>The repo does not commit <code>vendor/ffmpeg/</code>. You can build and stage a minimal GPL FFmpeg locally (x265 + AV1 only), and CI will also generate it for releases.</p>"},{"location":"development/#prerequisites-msys2-ucrt64","title":"Prerequisites (MSYS2 UCRT64)","text":"<pre><code>pacman -S --needed \\\n  base-devel git \\\n  mingw-w64-ucrt-x86_64-toolchain \\\n  mingw-w64-ucrt-x86_64-nasm mingw-w64-ucrt-x86_64-yasm \\\n  mingw-w64-ucrt-x86_64-pkg-config \\\n  mingw-w64-ucrt-x86_64-x264 \\\n  mingw-w64-ucrt-x86_64-x265 \\\n  mingw-w64-ucrt-x86_64-aom\n</code></pre>"},{"location":"development/#build-and-stage","title":"Build and Stage","text":"<pre><code>./scripts/build_ffmpeg_windows_msys2.sh\n</code></pre> <p>This script writes <code>ffmpeg.exe</code> and required DLLs to <code>vendor/ffmpeg/</code>, which the PyInstaller spec bundles automatically. To build a different version, set <code>FFMPEG_VERSION</code> (default: 8.0.1):</p> <pre><code>FFMPEG_VERSION=8.0.1 ./scripts/build_ffmpeg_windows_msys2.sh\n</code></pre>"},{"location":"development/#architecture","title":"Architecture","text":"<p>The package is organized with clear separation of concerns:</p>"},{"location":"development/#core-modules","title":"Core Modules","text":"<ul> <li><code>core/sequence.py</code>: Frame sequence detection and parsing</li> <li><code>core/converter.py</code>: Main conversion orchestrator</li> <li><code>core/config.py</code>: Configuration classes using Builder pattern</li> </ul>"},{"location":"development/#io-modules","title":"I/O Modules","text":"<ul> <li><code>io/image_reader.py</code>: Unified image reading using OpenImageIO (OIIO).</li> <li><code>io/file_utils.py</code>: File I/O utilities and output path validation.</li> </ul>"},{"location":"development/#processing-modules","title":"Processing Modules","text":"<ul> <li><code>processing/color_space.py</code>: Color space conversion using OCIO-inspired strategies.</li> <li><code>processing/scaler.py</code>: High-quality image scaling using OpenImageIO (Lanczos3).</li> <li><code>processing/video_encoder.py</code>: Quality-first video encoding (CRF) using FFmpeg.</li> </ul>"},{"location":"development/#interface-modules","title":"Interface Modules","text":"<ul> <li><code>api/processor.py</code>: Public Python API</li> <li><code>cli/main.py</code>: Command-line interface</li> <li><code>ui/main_window.py</code>: PySide/Qt graphical interface</li> </ul>"},{"location":"development/#design-patterns","title":"Design Patterns","text":"<ol> <li>Factory Pattern: <code>ImageReaderFactory</code> for creating appropriate image readers</li> <li>Strategy Pattern: <code>ColorSpaceConverter</code> with different color space strategies</li> <li>Builder Pattern: <code>ConversionConfigBuilder</code> for flexible configuration</li> <li>Command Pattern: CLI commands</li> </ol>"},{"location":"development/#cicd","title":"CI/CD","text":"<p>The project uses GitHub Actions for: - Linting and formatting (Ruff) - Type checking (mypy, non-blocking) - Tests on Windows and Ubuntu (Python 3.10) - UI tests on Ubuntu (xvfb) - Python package build on Ubuntu - PyInstaller builds on Windows, Linux, and macOS (Build workflow)</p>"},{"location":"usage/","title":"Usage Guide","text":""},{"location":"usage/#command-line-interface-cli","title":"Command Line Interface (CLI)","text":"<p>The CLI entrypoint is <code>renderkit</code>.</p>"},{"location":"usage/#examples","title":"Examples","text":"<pre><code># Basic conversion (high quality)\nrenderkit convert-exr-sequence render.%04d.exr output.mp4 --fps 24\n\n# Set specific visual quality (7 is a good balance)\nrenderkit convert-exr-sequence render.%04d.exr output.mp4 --quality 7\n\n# Using AV1 for maximum compression\nrenderkit convert-exr-sequence render.%04d.exr output.mp4 --codec libaom-av1 --quality 8\n\n# Multi-AOV contact sheet video\nrenderkit convert-exr-sequence render.%04d.exr output.mp4 --contact-sheet --cs-columns 4\n\n# Burn-in frame number and FPS\nrenderkit convert-exr-sequence render.%04d.exr output.mp4 --burnin-frame --burnin-fps\n</code></pre>"},{"location":"usage/#options","title":"Options","text":"Option Description Default <code>INPUT_PATTERN</code> File pattern with placeholders Required <code>OUTPUT_PATH</code> Output video file path Required <code>--fps</code> Frame rate Auto-detect <code>--quality</code> Visual Quality (0-10), 10 is best <code>10</code> <code>--color-space</code> <code>linear_to_srgb</code>, <code>linear_to_rec709</code>, <code>srgb_to_linear</code>, <code>no_conversion</code> <code>linear_to_srgb</code> <code>--width</code> Output width Source width <code>--height</code> Output height Source height <code>--codec</code> Video codec (<code>libx264</code>, <code>libx265</code>, <code>libaom-av1</code>) <code>libx264</code> <code>--layer</code> EXR layer/AOV to extract None <code>--start-frame</code> Start frame number First frame <code>--end-frame</code> End frame number Last frame <code>--overwrite</code> Overwrite output file if it exists <code>False</code> <code>--burnin-frame</code> Burn in frame number <code>False</code> <code>--burnin-layer</code> Burn in layer name <code>False</code> <code>--burnin-fps</code> Burn in frame rate <code>False</code> <code>--burnin-opacity</code> Burn-in background opacity (0-100) <code>30</code> <code>--contact-sheet</code> Enable multi-AOV grid mode <code>False</code> <code>--cs-columns</code> Contact sheet columns <code>4</code> <code>--cs-thumb-width</code> Width of each layer cell <code>512</code> <code>--cs-padding</code> Spacing between cells <code>10</code> <code>--cs-no-labels</code> Disable layer name labels <code>False</code>"},{"location":"usage/#python-api","title":"Python API","text":""},{"location":"usage/#basic-usage","title":"Basic Usage","text":"<pre><code>from renderkit import RenderKit\n\nprocessor = RenderKit()\nprocessor.convert_exr_sequence_to_mp4(\n    input_pattern=\"render.%04d.exr\",\n    output_path=\"output.mp4\",\n    fps=24.0,\n    quality=10,  # 0-10 scale\n    codec=\"libx264\",\n)\n</code></pre>"},{"location":"usage/#advanced-configuration","title":"Advanced Configuration","text":"<p>Use the Builder pattern for complex configurations:</p> <pre><code>from renderkit import RenderKit\nfrom renderkit.core.config import ContactSheetConfig, ConversionConfigBuilder\nfrom renderkit.processing.color_space import ColorSpacePreset\n\nconfig = (\n    ConversionConfigBuilder()\n    .with_input_pattern(\"render.%04d.exr\")\n    .with_output_path(\"output.mp4\")\n    .with_fps(24.0)\n    .with_color_space_preset(ColorSpacePreset.OCIO_CONVERSION)\n    .with_explicit_input_color_space(\"ACES - ACEScg\")\n    .with_resolution(3840, 2160)\n    .with_codec(\"libx264\")\n    .with_contact_sheet(\n        True,\n        ContactSheetConfig(columns=4, thumbnail_width=512, padding=10, show_labels=True),\n    )\n    .build()\n)\n\nprocessor = RenderKit()\nprocessor.convert_with_config(config)\n</code></pre>"},{"location":"usage/#graphical-interface-ui","title":"Graphical Interface (UI)","text":"<p>Launch the UI from the terminal:</p> <pre><code>python -m renderkit.ui.main_window\n</code></pre> <p>If you have a Pre-compiled build, run the exe in the <code>RenderKit/</code> folder.</p>"},{"location":"usage/#qt-backend","title":"Qt Backend","text":"<p>PySide6 is the supported backend. You can force a backend with <code>QT_BACKEND</code> if needed:</p> <pre><code># macOS/Linux\nexport QT_BACKEND=pyside6\n</code></pre> <pre><code># Windows PowerShell\n$env:QT_BACKEND = \"pyside6\"\n</code></pre>"},{"location":"usage/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>OCIO</code>: Path to your system OCIO config (used when selecting ACES/custom input spaces).</li> <li><code>IMAGEIO_FFMPEG_EXE</code>: Path to a custom ffmpeg binary (optional, for offline systems).</li> <li><code>RENDERKIT_FFMPEG_LOG</code>: FFmpeg report logging (default: on). Set to <code>0</code> to disable, <code>1</code> for temp log, or a full file path.</li> <li><code>RENDERKIT_LOG_PATH</code>: Override RenderKit log file path (default: temp dir <code>renderkit.log</code>).</li> <li><code>RENDERKIT_LOG_LEVEL</code>: Logging level (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, etc.).</li> <li><code>QT_BACKEND</code>: Force a Qt backend (default is auto-detect; PySide6 is recommended).</li> </ul>"},{"location":"api/config/","title":"Configuration","text":""},{"location":"api/config/#renderkit.core.config.ConversionConfig","title":"<code>renderkit.core.config.ConversionConfig</code>  <code>dataclass</code>","text":"<p>Configuration for image sequence to video conversion.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>@dataclass\nclass ConversionConfig:\n    \"\"\"Configuration for image sequence to video conversion.\"\"\"\n\n    input_pattern: str\n    output_path: str\n    fps: Optional[float] = None\n    color_space_preset: ColorSpacePreset = ColorSpacePreset.LINEAR_TO_SRGB\n    width: Optional[int] = None\n    height: Optional[int] = None\n    codec: str = \"libx264\"\n    bitrate: Optional[int] = None\n    quality: int = 10  # 0-10, 10 is best\n    layer: Optional[str] = None  # Specific layer to extract (e.g. \"diffuse\")\n    start_frame: Optional[int] = None\n    end_frame: Optional[int] = None\n    use_multiprocessing: bool = False\n    num_workers: Optional[int] = None\n    explicit_input_color_space: Optional[str] = (\n        None  # Force specific input space (e.g. \"ACES - ACEScg\")\n    )\n    burnin_config: Optional[BurnInConfig] = None\n    contact_sheet_mode: bool = False\n    contact_sheet_config: Optional[ContactSheetConfig] = None\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate configuration after initialization.\"\"\"\n        if self.fps is not None and self.fps &lt;= 0:\n            raise ConfigurationError(\"FPS must be greater than 0\")\n        if self.width is not None and self.width &lt;= 0:\n            raise ConfigurationError(\"Width must be greater than 0\")\n        if self.height is not None and self.height &lt;= 0:\n            raise ConfigurationError(\"Height must be greater than 0\")\n        if self.start_frame is not None and self.end_frame is not None:\n            if self.start_frame &gt; self.end_frame:\n                raise ConfigurationError(\"Start frame must be &lt;= end frame\")\n        if self.num_workers is not None and self.num_workers &lt;= 0:\n            raise ConfigurationError(\"Number of workers must be greater than 0\")\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate configuration after initialization.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration after initialization.\"\"\"\n    if self.fps is not None and self.fps &lt;= 0:\n        raise ConfigurationError(\"FPS must be greater than 0\")\n    if self.width is not None and self.width &lt;= 0:\n        raise ConfigurationError(\"Width must be greater than 0\")\n    if self.height is not None and self.height &lt;= 0:\n        raise ConfigurationError(\"Height must be greater than 0\")\n    if self.start_frame is not None and self.end_frame is not None:\n        if self.start_frame &gt; self.end_frame:\n            raise ConfigurationError(\"Start frame must be &lt;= end frame\")\n    if self.num_workers is not None and self.num_workers &lt;= 0:\n        raise ConfigurationError(\"Number of workers must be greater than 0\")\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder","title":"<code>renderkit.core.config.ConversionConfigBuilder</code>","text":"<p>Builder for ConversionConfig using Builder pattern.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>class ConversionConfigBuilder:\n    \"\"\"Builder for ConversionConfig using Builder pattern.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the builder.\"\"\"\n        self._input_pattern: Optional[str] = None\n        self._output_path: Optional[str] = None\n        self._fps: Optional[float] = None\n        self._color_space_preset: ColorSpacePreset = ColorSpacePreset.LINEAR_TO_SRGB\n        self._width: Optional[int] = None\n        self._height: Optional[int] = None\n        self._codec: str = \"libx264\"\n        self._bitrate: Optional[int] = None\n        self._quality: int = 10\n        self._layer: Optional[str] = None\n        self._start_frame: Optional[int] = None\n        self._end_frame: Optional[int] = None\n        self._use_multiprocessing: bool = False\n        self._num_workers: Optional[int] = None\n        self._explicit_input_color_space: Optional[str] = None\n        self._burnin_config: Optional[BurnInConfig] = None\n        self._contact_sheet_mode: bool = False\n        self._contact_sheet_config: Optional[ContactSheetConfig] = None\n\n    def with_input_pattern(self, pattern: str) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the input file pattern.\"\"\"\n        self._input_pattern = pattern\n        return self\n\n    def with_output_path(self, path: str) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the output video path.\"\"\"\n        self._output_path = path\n        return self\n\n    def with_fps(self, fps: float) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the frame rate.\"\"\"\n        self._fps = fps\n        return self\n\n    def with_color_space_preset(self, preset: ColorSpacePreset) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the color space preset.\"\"\"\n        self._color_space_preset = preset\n        return self\n\n    def with_explicit_input_color_space(self, space_name: str) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set explicit input color space name (for OCIO).\"\"\"\n        self._explicit_input_color_space = space_name\n        return self\n\n    def with_resolution(self, width: int, height: int) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the output resolution.\"\"\"\n        self._width = width\n        self._height = height\n        return self\n\n    def with_codec(self, codec: str) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the video codec.\"\"\"\n        self._codec = codec\n        return self\n\n    def with_bitrate(self, bitrate: int) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the video bitrate.\"\"\"\n        self._bitrate = bitrate\n        return self\n\n    def with_quality(self, quality: int) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the video quality (0-10).\"\"\"\n        self._quality = quality\n        return self\n\n    def with_layer(self, layer: str) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the EXR layer to extract.\"\"\"\n        self._layer = layer\n        return self\n\n    def with_frame_range(self, start: int, end: int) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the frame range.\"\"\"\n        self._start_frame = start\n        self._end_frame = end\n        return self\n\n    def with_multiprocessing(\n        self, enabled: bool = True, num_workers: Optional[int] = None\n    ) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Enable multiprocessing for batch operations.\"\"\"\n        self._use_multiprocessing = enabled\n        self._num_workers = num_workers\n        return self\n\n    def with_burnin(self, config: BurnInConfig) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Set the burn-in configuration.\"\"\"\n        self._burnin_config = config\n        return self\n\n    def with_contact_sheet(\n        self, enabled: bool = True, config: Optional[ContactSheetConfig] = None\n    ) -&gt; \"ConversionConfigBuilder\":\n        \"\"\"Enable contact sheet mode.\"\"\"\n        self._contact_sheet_mode = enabled\n        self._contact_sheet_config = config\n        return self\n\n    def build(self) -&gt; ConversionConfig:\n        \"\"\"Build the ConversionConfig object.\"\"\"\n        if self._input_pattern is None:\n            raise ConfigurationError(\"Input pattern is required\")\n        if self._output_path is None:\n            raise ConfigurationError(\"Output path is required\")\n\n        return ConversionConfig(\n            input_pattern=self._input_pattern,\n            output_path=self._output_path,\n            fps=self._fps,\n            color_space_preset=self._color_space_preset,\n            width=self._width,\n            height=self._height,\n            codec=self._codec,\n            bitrate=self._bitrate,\n            quality=self._quality,\n            layer=self._layer,\n            start_frame=self._start_frame,\n            end_frame=self._end_frame,\n            use_multiprocessing=self._use_multiprocessing,\n            num_workers=self._num_workers,\n            explicit_input_color_space=self._explicit_input_color_space,\n            burnin_config=self._burnin_config,\n            contact_sheet_mode=self._contact_sheet_mode,\n            contact_sheet_config=self._contact_sheet_config,\n        )\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the builder.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the builder.\"\"\"\n    self._input_pattern: Optional[str] = None\n    self._output_path: Optional[str] = None\n    self._fps: Optional[float] = None\n    self._color_space_preset: ColorSpacePreset = ColorSpacePreset.LINEAR_TO_SRGB\n    self._width: Optional[int] = None\n    self._height: Optional[int] = None\n    self._codec: str = \"libx264\"\n    self._bitrate: Optional[int] = None\n    self._quality: int = 10\n    self._layer: Optional[str] = None\n    self._start_frame: Optional[int] = None\n    self._end_frame: Optional[int] = None\n    self._use_multiprocessing: bool = False\n    self._num_workers: Optional[int] = None\n    self._explicit_input_color_space: Optional[str] = None\n    self._burnin_config: Optional[BurnInConfig] = None\n    self._contact_sheet_mode: bool = False\n    self._contact_sheet_config: Optional[ContactSheetConfig] = None\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.build","title":"<code>build()</code>","text":"<p>Build the ConversionConfig object.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def build(self) -&gt; ConversionConfig:\n    \"\"\"Build the ConversionConfig object.\"\"\"\n    if self._input_pattern is None:\n        raise ConfigurationError(\"Input pattern is required\")\n    if self._output_path is None:\n        raise ConfigurationError(\"Output path is required\")\n\n    return ConversionConfig(\n        input_pattern=self._input_pattern,\n        output_path=self._output_path,\n        fps=self._fps,\n        color_space_preset=self._color_space_preset,\n        width=self._width,\n        height=self._height,\n        codec=self._codec,\n        bitrate=self._bitrate,\n        quality=self._quality,\n        layer=self._layer,\n        start_frame=self._start_frame,\n        end_frame=self._end_frame,\n        use_multiprocessing=self._use_multiprocessing,\n        num_workers=self._num_workers,\n        explicit_input_color_space=self._explicit_input_color_space,\n        burnin_config=self._burnin_config,\n        contact_sheet_mode=self._contact_sheet_mode,\n        contact_sheet_config=self._contact_sheet_config,\n    )\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_bitrate","title":"<code>with_bitrate(bitrate)</code>","text":"<p>Set the video bitrate.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_bitrate(self, bitrate: int) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the video bitrate.\"\"\"\n    self._bitrate = bitrate\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_burnin","title":"<code>with_burnin(config)</code>","text":"<p>Set the burn-in configuration.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_burnin(self, config: BurnInConfig) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the burn-in configuration.\"\"\"\n    self._burnin_config = config\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_codec","title":"<code>with_codec(codec)</code>","text":"<p>Set the video codec.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_codec(self, codec: str) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the video codec.\"\"\"\n    self._codec = codec\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_color_space_preset","title":"<code>with_color_space_preset(preset)</code>","text":"<p>Set the color space preset.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_color_space_preset(self, preset: ColorSpacePreset) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the color space preset.\"\"\"\n    self._color_space_preset = preset\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_contact_sheet","title":"<code>with_contact_sheet(enabled=True, config=None)</code>","text":"<p>Enable contact sheet mode.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_contact_sheet(\n    self, enabled: bool = True, config: Optional[ContactSheetConfig] = None\n) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Enable contact sheet mode.\"\"\"\n    self._contact_sheet_mode = enabled\n    self._contact_sheet_config = config\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_explicit_input_color_space","title":"<code>with_explicit_input_color_space(space_name)</code>","text":"<p>Set explicit input color space name (for OCIO).</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_explicit_input_color_space(self, space_name: str) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set explicit input color space name (for OCIO).\"\"\"\n    self._explicit_input_color_space = space_name\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_fps","title":"<code>with_fps(fps)</code>","text":"<p>Set the frame rate.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_fps(self, fps: float) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the frame rate.\"\"\"\n    self._fps = fps\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_frame_range","title":"<code>with_frame_range(start, end)</code>","text":"<p>Set the frame range.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_frame_range(self, start: int, end: int) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the frame range.\"\"\"\n    self._start_frame = start\n    self._end_frame = end\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_input_pattern","title":"<code>with_input_pattern(pattern)</code>","text":"<p>Set the input file pattern.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_input_pattern(self, pattern: str) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the input file pattern.\"\"\"\n    self._input_pattern = pattern\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_layer","title":"<code>with_layer(layer)</code>","text":"<p>Set the EXR layer to extract.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_layer(self, layer: str) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the EXR layer to extract.\"\"\"\n    self._layer = layer\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_multiprocessing","title":"<code>with_multiprocessing(enabled=True, num_workers=None)</code>","text":"<p>Enable multiprocessing for batch operations.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_multiprocessing(\n    self, enabled: bool = True, num_workers: Optional[int] = None\n) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Enable multiprocessing for batch operations.\"\"\"\n    self._use_multiprocessing = enabled\n    self._num_workers = num_workers\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_output_path","title":"<code>with_output_path(path)</code>","text":"<p>Set the output video path.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_output_path(self, path: str) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the output video path.\"\"\"\n    self._output_path = path\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_quality","title":"<code>with_quality(quality)</code>","text":"<p>Set the video quality (0-10).</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_quality(self, quality: int) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the video quality (0-10).\"\"\"\n    self._quality = quality\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ConversionConfigBuilder.with_resolution","title":"<code>with_resolution(width, height)</code>","text":"<p>Set the output resolution.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_resolution(self, width: int, height: int) -&gt; \"ConversionConfigBuilder\":\n    \"\"\"Set the output resolution.\"\"\"\n    self._width = width\n    self._height = height\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ContactSheetConfig","title":"<code>renderkit.core.config.ContactSheetConfig</code>  <code>dataclass</code>","text":"<p>Configuration for contact sheet layout in multi-AOV mode.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>@dataclass\nclass ContactSheetConfig:\n    \"\"\"Configuration for contact sheet layout in multi-AOV mode.\"\"\"\n\n    columns: int = 4\n    thumbnail_width: int = 512\n    padding: int = 10\n    background_color: tuple[float, float, float] = (0.1, 0.1, 0.1)\n    show_labels: bool = True\n    font_size: int = 12\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate configuration.\"\"\"\n        if self.columns &lt;= 0:\n            raise ConfigurationError(\"Columns must be greater than 0\")\n        if self.thumbnail_width &lt;= 0:\n            raise ConfigurationError(\"Thumbnail width must be greater than 0\")\n        if self.padding &lt; 0:\n            raise ConfigurationError(\"Padding cannot be negative\")\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ContactSheetConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate configuration.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration.\"\"\"\n    if self.columns &lt;= 0:\n        raise ConfigurationError(\"Columns must be greater than 0\")\n    if self.thumbnail_width &lt;= 0:\n        raise ConfigurationError(\"Thumbnail width must be greater than 0\")\n    if self.padding &lt; 0:\n        raise ConfigurationError(\"Padding cannot be negative\")\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ContactSheetConfigBuilder","title":"<code>renderkit.core.config.ContactSheetConfigBuilder</code>","text":"<p>Builder for ContactSheetConfig.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>class ContactSheetConfigBuilder:\n    \"\"\"Builder for ContactSheetConfig.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize builder.\"\"\"\n        self._columns: int = 4\n        self._thumbnail_width: int = 512\n        self._padding: int = 10\n        self._background_color: tuple[float, float, float] = (0.1, 0.1, 0.1)\n        self._show_labels: bool = True\n        self._font_size: int = 12\n\n    def with_columns(self, columns: int) -&gt; \"ContactSheetConfigBuilder\":\n        \"\"\"Set number of columns.\"\"\"\n        self._columns = columns\n        return self\n\n    def with_thumbnail_width(self, width: int) -&gt; \"ContactSheetConfigBuilder\":\n        \"\"\"Set thumbnail width.\"\"\"\n        self._thumbnail_width = width\n        return self\n\n    def with_padding(self, padding: int) -&gt; \"ContactSheetConfigBuilder\":\n        \"\"\"Set padding between thumbnails.\"\"\"\n        self._padding = padding\n        return self\n\n    def with_labels(self, show: bool, font_size: int = 12) -&gt; \"ContactSheetConfigBuilder\":\n        \"\"\"Set label options.\"\"\"\n        self._show_labels = show\n        self._font_size = font_size\n        return self\n\n    def build(self) -&gt; ContactSheetConfig:\n        \"\"\"Build ContactSheetConfig.\"\"\"\n        return ContactSheetConfig(\n            columns=self._columns,\n            thumbnail_width=self._thumbnail_width,\n            padding=self._padding,\n            background_color=self._background_color,\n            show_labels=self._show_labels,\n            font_size=self._font_size,\n        )\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ContactSheetConfigBuilder.__init__","title":"<code>__init__()</code>","text":"<p>Initialize builder.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize builder.\"\"\"\n    self._columns: int = 4\n    self._thumbnail_width: int = 512\n    self._padding: int = 10\n    self._background_color: tuple[float, float, float] = (0.1, 0.1, 0.1)\n    self._show_labels: bool = True\n    self._font_size: int = 12\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ContactSheetConfigBuilder.build","title":"<code>build()</code>","text":"<p>Build ContactSheetConfig.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def build(self) -&gt; ContactSheetConfig:\n    \"\"\"Build ContactSheetConfig.\"\"\"\n    return ContactSheetConfig(\n        columns=self._columns,\n        thumbnail_width=self._thumbnail_width,\n        padding=self._padding,\n        background_color=self._background_color,\n        show_labels=self._show_labels,\n        font_size=self._font_size,\n    )\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ContactSheetConfigBuilder.with_columns","title":"<code>with_columns(columns)</code>","text":"<p>Set number of columns.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_columns(self, columns: int) -&gt; \"ContactSheetConfigBuilder\":\n    \"\"\"Set number of columns.\"\"\"\n    self._columns = columns\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ContactSheetConfigBuilder.with_labels","title":"<code>with_labels(show, font_size=12)</code>","text":"<p>Set label options.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_labels(self, show: bool, font_size: int = 12) -&gt; \"ContactSheetConfigBuilder\":\n    \"\"\"Set label options.\"\"\"\n    self._show_labels = show\n    self._font_size = font_size\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ContactSheetConfigBuilder.with_padding","title":"<code>with_padding(padding)</code>","text":"<p>Set padding between thumbnails.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_padding(self, padding: int) -&gt; \"ContactSheetConfigBuilder\":\n    \"\"\"Set padding between thumbnails.\"\"\"\n    self._padding = padding\n    return self\n</code></pre>"},{"location":"api/config/#renderkit.core.config.ContactSheetConfigBuilder.with_thumbnail_width","title":"<code>with_thumbnail_width(width)</code>","text":"<p>Set thumbnail width.</p> Source code in <code>src/renderkit/core/config.py</code> <pre><code>def with_thumbnail_width(self, width: int) -&gt; \"ContactSheetConfigBuilder\":\n    \"\"\"Set thumbnail width.\"\"\"\n    self._thumbnail_width = width\n    return self\n</code></pre>"},{"location":"api/processor/","title":"RenderKit","text":""},{"location":"api/processor/#renderkit.api.processor.RenderKit","title":"<code>renderkit.api.processor.RenderKit</code>","text":"<p>Main public API for image and video processing.</p> Source code in <code>src/renderkit/api/processor.py</code> <pre><code>class RenderKit:\n    \"\"\"Main public API for image and video processing.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize RenderKit.\"\"\"\n        ensure_ffmpeg_env()\n        setup_logging()\n\n    def convert_exr_sequence_to_mp4(\n        self,\n        input_pattern: str,\n        output_path: str,\n        fps: Optional[float] = None,\n        color_space_preset: ColorSpacePreset = ColorSpacePreset.LINEAR_TO_SRGB,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        codec: str = \"libx264\",\n        quality: int = 10,\n        layer: Optional[str] = None,\n        start_frame: Optional[int] = None,\n        end_frame: Optional[int] = None,\n        contact_sheet: bool = False,\n        contact_sheet_config: Optional[ContactSheetConfig] = None,\n    ) -&gt; None:\n        \"\"\"Convert an EXR sequence to MP4 video.\n\n        Args:\n            input_pattern: Input file pattern (e.g., \"render.%04d.exr\")\n            output_path: Output video file path\n            fps: Frame rate (optional, will try to auto-detect if not provided)\n            color_space_preset: Color space conversion preset\n            width: Output width (optional, uses source width if not provided)\n            height: Output height (optional, uses source height if not provided)\n            codec: Video codec (default: \"libx264\")\n            quality: Video quality (0-10), 10 is best (default: 10)\n            layer: Optional EXR layer to extract (default: None)\n            start_frame: Start frame number (optional)\n            end_frame: End frame number (optional)\n\n        Example:\n            &gt;&gt;&gt; processor = RenderKit()\n            &gt;&gt;&gt; processor.convert_exr_sequence_to_mp4(\n            ...     \"render.%04d.exr\",\n            ...     \"output.mp4\",\n            ...     fps=24.0,\n            ...     quality=10,\n            ...     layer=\"diffuse\"\n            ... )\n        \"\"\"\n        config = (\n            ConversionConfigBuilder()\n            .with_input_pattern(input_pattern)\n            .with_output_path(output_path)\n            .with_fps(fps)\n            .with_color_space_preset(color_space_preset)\n            .with_codec(codec)\n            .with_quality(quality)\n            .with_layer(layer)\n        )\n\n        if width is not None and height is not None:\n            config.with_resolution(width, height)\n\n        if start_frame is not None and end_frame is not None:\n            config.with_frame_range(start_frame, end_frame)\n        elif start_frame is not None:\n            config.with_frame_range(start_frame, start_frame)\n        elif end_frame is not None:\n            config.with_frame_range(0, end_frame)\n\n        if contact_sheet:\n            config.with_contact_sheet(True, contact_sheet_config)\n\n        conversion_config = config.build()\n        converter = SequenceConverter(conversion_config)\n        converter.convert()\n\n    def convert_with_config(self, config: ConversionConfig) -&gt; None:\n        \"\"\"Convert using a ConversionConfig object.\n\n        Args:\n            config: Conversion configuration object\n\n        Example:\n            &gt;&gt;&gt; from renderkit.core.config import ConversionConfigBuilder\n            &gt;&gt;&gt; config = ConversionConfigBuilder()\\\\\n            ...     .with_input_pattern(\"render.%04d.exr\")\\\\\n            ...     .with_output_path(\"output.mp4\")\\\\\n            ...     .with_fps(24.0)\\\\\n            ...     .build()\n            &gt;&gt;&gt; processor = RenderKit()\n            &gt;&gt;&gt; processor.convert_with_config(config)\n        \"\"\"\n        converter = SequenceConverter(config)\n        converter.convert()\n</code></pre>"},{"location":"api/processor/#renderkit.api.processor.RenderKit.__init__","title":"<code>__init__()</code>","text":"<p>Initialize RenderKit.</p> Source code in <code>src/renderkit/api/processor.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize RenderKit.\"\"\"\n    ensure_ffmpeg_env()\n    setup_logging()\n</code></pre>"},{"location":"api/processor/#renderkit.api.processor.RenderKit.convert_exr_sequence_to_mp4","title":"<code>convert_exr_sequence_to_mp4(input_pattern, output_path, fps=None, color_space_preset=ColorSpacePreset.LINEAR_TO_SRGB, width=None, height=None, codec='libx264', quality=10, layer=None, start_frame=None, end_frame=None, contact_sheet=False, contact_sheet_config=None)</code>","text":"<p>Convert an EXR sequence to MP4 video.</p> <p>Parameters:</p> Name Type Description Default <code>input_pattern</code> <code>str</code> <p>Input file pattern (e.g., \"render.%04d.exr\")</p> required <code>output_path</code> <code>str</code> <p>Output video file path</p> required <code>fps</code> <code>Optional[float]</code> <p>Frame rate (optional, will try to auto-detect if not provided)</p> <code>None</code> <code>color_space_preset</code> <code>ColorSpacePreset</code> <p>Color space conversion preset</p> <code>LINEAR_TO_SRGB</code> <code>width</code> <code>Optional[int]</code> <p>Output width (optional, uses source width if not provided)</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>Output height (optional, uses source height if not provided)</p> <code>None</code> <code>codec</code> <code>str</code> <p>Video codec (default: \"libx264\")</p> <code>'libx264'</code> <code>quality</code> <code>int</code> <p>Video quality (0-10), 10 is best (default: 10)</p> <code>10</code> <code>layer</code> <code>Optional[str]</code> <p>Optional EXR layer to extract (default: None)</p> <code>None</code> <code>start_frame</code> <code>Optional[int]</code> <p>Start frame number (optional)</p> <code>None</code> <code>end_frame</code> <code>Optional[int]</code> <p>End frame number (optional)</p> <code>None</code> Example <p>processor = RenderKit() processor.convert_exr_sequence_to_mp4( ...     \"render.%04d.exr\", ...     \"output.mp4\", ...     fps=24.0, ...     quality=10, ...     layer=\"diffuse\" ... )</p> Source code in <code>src/renderkit/api/processor.py</code> <pre><code>def convert_exr_sequence_to_mp4(\n    self,\n    input_pattern: str,\n    output_path: str,\n    fps: Optional[float] = None,\n    color_space_preset: ColorSpacePreset = ColorSpacePreset.LINEAR_TO_SRGB,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    codec: str = \"libx264\",\n    quality: int = 10,\n    layer: Optional[str] = None,\n    start_frame: Optional[int] = None,\n    end_frame: Optional[int] = None,\n    contact_sheet: bool = False,\n    contact_sheet_config: Optional[ContactSheetConfig] = None,\n) -&gt; None:\n    \"\"\"Convert an EXR sequence to MP4 video.\n\n    Args:\n        input_pattern: Input file pattern (e.g., \"render.%04d.exr\")\n        output_path: Output video file path\n        fps: Frame rate (optional, will try to auto-detect if not provided)\n        color_space_preset: Color space conversion preset\n        width: Output width (optional, uses source width if not provided)\n        height: Output height (optional, uses source height if not provided)\n        codec: Video codec (default: \"libx264\")\n        quality: Video quality (0-10), 10 is best (default: 10)\n        layer: Optional EXR layer to extract (default: None)\n        start_frame: Start frame number (optional)\n        end_frame: End frame number (optional)\n\n    Example:\n        &gt;&gt;&gt; processor = RenderKit()\n        &gt;&gt;&gt; processor.convert_exr_sequence_to_mp4(\n        ...     \"render.%04d.exr\",\n        ...     \"output.mp4\",\n        ...     fps=24.0,\n        ...     quality=10,\n        ...     layer=\"diffuse\"\n        ... )\n    \"\"\"\n    config = (\n        ConversionConfigBuilder()\n        .with_input_pattern(input_pattern)\n        .with_output_path(output_path)\n        .with_fps(fps)\n        .with_color_space_preset(color_space_preset)\n        .with_codec(codec)\n        .with_quality(quality)\n        .with_layer(layer)\n    )\n\n    if width is not None and height is not None:\n        config.with_resolution(width, height)\n\n    if start_frame is not None and end_frame is not None:\n        config.with_frame_range(start_frame, end_frame)\n    elif start_frame is not None:\n        config.with_frame_range(start_frame, start_frame)\n    elif end_frame is not None:\n        config.with_frame_range(0, end_frame)\n\n    if contact_sheet:\n        config.with_contact_sheet(True, contact_sheet_config)\n\n    conversion_config = config.build()\n    converter = SequenceConverter(conversion_config)\n    converter.convert()\n</code></pre>"},{"location":"api/processor/#renderkit.api.processor.RenderKit.convert_with_config","title":"<code>convert_with_config(config)</code>","text":"<p>Convert using a ConversionConfig object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConversionConfig</code> <p>Conversion configuration object</p> required Example <p>from renderkit.core.config import ConversionConfigBuilder config = ConversionConfigBuilder()\\ ...     .with_input_pattern(\"render.%04d.exr\")\\ ...     .with_output_path(\"output.mp4\")\\ ...     .with_fps(24.0)\\ ...     .build() processor = RenderKit() processor.convert_with_config(config)</p> Source code in <code>src/renderkit/api/processor.py</code> <pre><code>def convert_with_config(self, config: ConversionConfig) -&gt; None:\n    \"\"\"Convert using a ConversionConfig object.\n\n    Args:\n        config: Conversion configuration object\n\n    Example:\n        &gt;&gt;&gt; from renderkit.core.config import ConversionConfigBuilder\n        &gt;&gt;&gt; config = ConversionConfigBuilder()\\\\\n        ...     .with_input_pattern(\"render.%04d.exr\")\\\\\n        ...     .with_output_path(\"output.mp4\")\\\\\n        ...     .with_fps(24.0)\\\\\n        ...     .build()\n        &gt;&gt;&gt; processor = RenderKit()\n        &gt;&gt;&gt; processor.convert_with_config(config)\n    \"\"\"\n    converter = SequenceConverter(config)\n    converter.convert()\n</code></pre>"},{"location":"api/sequence/","title":"Sequence Detection","text":""},{"location":"api/sequence/#renderkit.core.sequence.SequenceDetector","title":"<code>renderkit.core.sequence.SequenceDetector</code>","text":"<p>Detects and parses frame sequences from file patterns.</p> Source code in <code>src/renderkit/core/sequence.py</code> <pre><code>class SequenceDetector:\n    \"\"\"Detects and parses frame sequences from file patterns.\"\"\"\n\n    # Common VFX frame number patterns\n    PATTERNS = [\n        (r\"%(\\d+)d\", \"%04d\"),  # Houdini style: render.%04d.exr\n        (r\"\\$F(\\d+)\", \"$F4\"),  # Houdini style: render.$F4.exr\n        (r\"(#+)\", \"####\"),  # Maya style: render.####.exr\n        (r\"(\\d+)\", \"0001\"),  # Numeric: render.0001.exr\n    ]\n\n    @staticmethod\n    def detect_sequence(pattern: str) -&gt; FrameSequence:\n        \"\"\"Detect a frame sequence from a pattern string.\n\n        Supports patterns like:\n        - render.%04d.exr (Houdini)\n        - render.$F4.exr (Houdini)\n        - render.####.exr (Maya)\n        - render.0001.exr (numeric)\n\n        Args:\n            pattern: File pattern with frame number placeholder\n\n        Returns:\n            FrameSequence object\n\n        Raises:\n            SequenceDetectionError: If sequence cannot be detected\n        \"\"\"\n        pattern_path = Path(pattern)\n        base_path = pattern_path.parent\n        filename = pattern_path.name\n\n        # Try to detect which pattern is being used\n        detected_pattern = None\n        padding = 4\n        frame_numbers: list[int] = []\n\n        # Check for %04d pattern\n        if \"%\" in filename and \"d\" in filename:\n            match = re.search(r\"%(\\d+)d\", filename)\n            if match:\n                padding = int(match.group(1))\n                detected_pattern = filename\n                # Find all matching files\n                frame_numbers = SequenceDetector._find_frames_by_pattern(\n                    base_path, filename, padding, \"%04d\"\n                )\n\n        # Check for $F4 pattern\n        elif \"$F\" in filename:\n            match = re.search(r\"\\$F(\\d+)\", filename)\n            if match:\n                padding = int(match.group(1))\n                detected_pattern = filename\n                frame_numbers = SequenceDetector._find_frames_by_pattern(\n                    base_path, filename, padding, \"$F4\"\n                )\n\n        # Check for #### pattern\n        elif \"#\" in filename:\n            match = re.search(r\"(#+)\", filename)\n            if match:\n                padding = len(match.group(1))\n                detected_pattern = filename\n                frame_numbers = SequenceDetector._find_frames_by_pattern(\n                    base_path, filename, padding, \"####\"\n                )\n\n        # Check for numeric pattern (e.g., render.0001.exr)\n        else:\n            numeric_match = re.search(r\"(\\d+)\", filename)\n            if numeric_match:\n                # Try to find sequence by replacing the number\n                frame_numbers = SequenceDetector._find_frames_by_numeric_pattern(\n                    base_path, filename, numeric_match\n                )\n                if frame_numbers:\n                    padding = len(numeric_match.group(1))\n                    detected_pattern = filename\n\n        if not frame_numbers:\n            raise SequenceDetectionError(\"Could not detect frame sequence.\")\n\n        return FrameSequence(base_path, detected_pattern or filename, frame_numbers, padding)\n\n    @staticmethod\n    def _find_frames_by_pattern(\n        base_path: Path, pattern: str, padding: int, placeholder: str\n    ) -&gt; list[int]:\n        \"\"\"Find frame numbers matching a pattern.\n\n        Args:\n            base_path: Directory to search\n            pattern: Pattern string with placeholder\n            padding: Number of digits for padding\n            placeholder: The placeholder string to replace\n\n        Returns:\n            List of frame numbers found\n        \"\"\"\n        frame_numbers: list[int] = []\n        pattern_regex = pattern\n\n        # Convert pattern to regex\n        if placeholder == \"%04d\":\n            pattern_regex = re.sub(r\"%\\d+d\", lambda m: r\"(\\d+)\", pattern)\n        elif placeholder == \"$F4\":\n            pattern_regex = re.sub(r\"\\$F\\d+\", lambda m: r\"(\\d+)\", pattern)\n        elif placeholder == \"####\":\n            pattern_regex = re.sub(r\"#+\", lambda m: r\"(\\d+)\", pattern)\n\n        regex = re.compile(pattern_regex)\n\n        # Search for matching files\n        if base_path.exists():\n            for file_path in base_path.iterdir():\n                if file_path.is_file():\n                    match = regex.match(file_path.name)\n                    if match:\n                        try:\n                            frame_num = int(match.group(1))\n                            frame_numbers.append(frame_num)\n                        except (ValueError, IndexError):\n                            continue\n\n        return sorted(frame_numbers)\n\n    @staticmethod\n    def _find_frames_by_numeric_pattern(\n        base_path: Path, filename: str, numeric_match: re.Match[str]\n    ) -&gt; list[int]:\n        \"\"\"Find frame numbers by replacing numeric part of filename.\n\n        Args:\n            base_path: Directory to search\n            filename: Filename with numeric pattern\n            numeric_match: Regex match object for the numeric part\n\n        Returns:\n            List of frame numbers found\n        \"\"\"\n        frame_numbers: list[int] = []\n        start_pos, end_pos = numeric_match.span()\n        prefix = filename[:start_pos]\n        suffix = filename[end_pos:]\n\n        # Try to find files with same prefix/suffix but different numbers\n        if base_path.exists():\n            pattern_regex = re.compile(re.escape(prefix) + r\"(\\d+)\" + re.escape(suffix))\n            for file_path in base_path.iterdir():\n                if file_path.is_file():\n                    match = pattern_regex.match(file_path.name)\n                    if match:\n                        try:\n                            frame_num = int(match.group(1))\n                            frame_numbers.append(frame_num)\n                        except ValueError:\n                            continue\n\n        return sorted(frame_numbers)\n\n    @staticmethod\n    def auto_detect_fps(\n        frame_numbers: list[int],\n        default_fps: Optional[float] = None,\n        sample_path: Optional[Path] = None,\n    ) -&gt; Optional[float]:\n        \"\"\"Auto-detect frame rate from frame numbers or metadata.\n\n        Args:\n            frame_numbers: List of frame numbers\n            default_fps: Default FPS to return if detection fails\n            sample_path: Optional path to a file in the sequence to check for metadata\n\n        Returns:\n            Detected FPS or default, or None if cannot determine\n        \"\"\"\n        # 1. Try metadata first if a sample path (e.g. first frame) is provided\n        if sample_path and sample_path.exists():\n            try:\n                from renderkit.io.image_reader import ImageReaderFactory\n\n                reader = ImageReaderFactory.create_reader(sample_path)\n                fps = reader.get_metadata_fps(sample_path)\n                if fps is not None:\n                    return round(fps, 3)  # Round to avoid precision issues (e.g. 23.976)\n            except Exception:\n                # Silently fail for metadata detection\n                pass\n\n        # 2. Return default or None\n        return default_fps\n</code></pre>"},{"location":"api/sequence/#renderkit.core.sequence.SequenceDetector.auto_detect_fps","title":"<code>auto_detect_fps(frame_numbers, default_fps=None, sample_path=None)</code>  <code>staticmethod</code>","text":"<p>Auto-detect frame rate from frame numbers or metadata.</p> <p>Parameters:</p> Name Type Description Default <code>frame_numbers</code> <code>list[int]</code> <p>List of frame numbers</p> required <code>default_fps</code> <code>Optional[float]</code> <p>Default FPS to return if detection fails</p> <code>None</code> <code>sample_path</code> <code>Optional[Path]</code> <p>Optional path to a file in the sequence to check for metadata</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>Detected FPS or default, or None if cannot determine</p> Source code in <code>src/renderkit/core/sequence.py</code> <pre><code>@staticmethod\ndef auto_detect_fps(\n    frame_numbers: list[int],\n    default_fps: Optional[float] = None,\n    sample_path: Optional[Path] = None,\n) -&gt; Optional[float]:\n    \"\"\"Auto-detect frame rate from frame numbers or metadata.\n\n    Args:\n        frame_numbers: List of frame numbers\n        default_fps: Default FPS to return if detection fails\n        sample_path: Optional path to a file in the sequence to check for metadata\n\n    Returns:\n        Detected FPS or default, or None if cannot determine\n    \"\"\"\n    # 1. Try metadata first if a sample path (e.g. first frame) is provided\n    if sample_path and sample_path.exists():\n        try:\n            from renderkit.io.image_reader import ImageReaderFactory\n\n            reader = ImageReaderFactory.create_reader(sample_path)\n            fps = reader.get_metadata_fps(sample_path)\n            if fps is not None:\n                return round(fps, 3)  # Round to avoid precision issues (e.g. 23.976)\n        except Exception:\n            # Silently fail for metadata detection\n            pass\n\n    # 2. Return default or None\n    return default_fps\n</code></pre>"},{"location":"api/sequence/#renderkit.core.sequence.SequenceDetector.detect_sequence","title":"<code>detect_sequence(pattern)</code>  <code>staticmethod</code>","text":"<p>Detect a frame sequence from a pattern string.</p> <p>Supports patterns like: - render.%04d.exr (Houdini) - render.$F4.exr (Houdini) - render.####.exr (Maya) - render.0001.exr (numeric)</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>File pattern with frame number placeholder</p> required <p>Returns:</p> Type Description <code>FrameSequence</code> <p>FrameSequence object</p> <p>Raises:</p> Type Description <code>SequenceDetectionError</code> <p>If sequence cannot be detected</p> Source code in <code>src/renderkit/core/sequence.py</code> <pre><code>@staticmethod\ndef detect_sequence(pattern: str) -&gt; FrameSequence:\n    \"\"\"Detect a frame sequence from a pattern string.\n\n    Supports patterns like:\n    - render.%04d.exr (Houdini)\n    - render.$F4.exr (Houdini)\n    - render.####.exr (Maya)\n    - render.0001.exr (numeric)\n\n    Args:\n        pattern: File pattern with frame number placeholder\n\n    Returns:\n        FrameSequence object\n\n    Raises:\n        SequenceDetectionError: If sequence cannot be detected\n    \"\"\"\n    pattern_path = Path(pattern)\n    base_path = pattern_path.parent\n    filename = pattern_path.name\n\n    # Try to detect which pattern is being used\n    detected_pattern = None\n    padding = 4\n    frame_numbers: list[int] = []\n\n    # Check for %04d pattern\n    if \"%\" in filename and \"d\" in filename:\n        match = re.search(r\"%(\\d+)d\", filename)\n        if match:\n            padding = int(match.group(1))\n            detected_pattern = filename\n            # Find all matching files\n            frame_numbers = SequenceDetector._find_frames_by_pattern(\n                base_path, filename, padding, \"%04d\"\n            )\n\n    # Check for $F4 pattern\n    elif \"$F\" in filename:\n        match = re.search(r\"\\$F(\\d+)\", filename)\n        if match:\n            padding = int(match.group(1))\n            detected_pattern = filename\n            frame_numbers = SequenceDetector._find_frames_by_pattern(\n                base_path, filename, padding, \"$F4\"\n            )\n\n    # Check for #### pattern\n    elif \"#\" in filename:\n        match = re.search(r\"(#+)\", filename)\n        if match:\n            padding = len(match.group(1))\n            detected_pattern = filename\n            frame_numbers = SequenceDetector._find_frames_by_pattern(\n                base_path, filename, padding, \"####\"\n            )\n\n    # Check for numeric pattern (e.g., render.0001.exr)\n    else:\n        numeric_match = re.search(r\"(\\d+)\", filename)\n        if numeric_match:\n            # Try to find sequence by replacing the number\n            frame_numbers = SequenceDetector._find_frames_by_numeric_pattern(\n                base_path, filename, numeric_match\n            )\n            if frame_numbers:\n                padding = len(numeric_match.group(1))\n                detected_pattern = filename\n\n    if not frame_numbers:\n        raise SequenceDetectionError(\"Could not detect frame sequence.\")\n\n    return FrameSequence(base_path, detected_pattern or filename, frame_numbers, padding)\n</code></pre>"},{"location":"api/io/file_utils/","title":"File Utilities","text":""},{"location":"api/io/file_utils/#renderkit.io.file_utils.FileUtils","title":"<code>renderkit.io.file_utils.FileUtils</code>","text":"<p>Utility class for file operations.</p> Source code in <code>src/renderkit/io/file_utils.py</code> <pre><code>class FileUtils:\n    \"\"\"Utility class for file operations.\"\"\"\n\n    @staticmethod\n    def ensure_directory(path: Path) -&gt; None:\n        \"\"\"Ensure a directory exists, creating it if necessary.\n\n        Args:\n            path: Path to the directory\n        \"\"\"\n        path.mkdir(parents=True, exist_ok=True)\n\n    @staticmethod\n    def get_file_extension(path: Path) -&gt; str:\n        \"\"\"Get the file extension (lowercase, without dot).\n\n        Args:\n            path: Path to the file\n\n        Returns:\n            File extension\n        \"\"\"\n        return path.suffix.lower().lstrip(\".\")\n\n    @staticmethod\n    def is_image_file(path: Path) -&gt; bool:\n        \"\"\"Check if a file is a supported image format.\n\n        Args:\n            path: Path to the file\n\n        Returns:\n            True if file is a supported image format\n        \"\"\"\n        return FileUtils.get_file_extension(path) in constants.OIIO_SUPPORTED_EXTENSIONS\n\n    @staticmethod\n    def find_files_by_pattern(directory: Path, pattern: str, recursive: bool = False) -&gt; list[Path]:\n        \"\"\"Find files matching a pattern.\n\n        Args:\n            directory: Directory to search\n            pattern: Filename pattern (supports wildcards)\n            recursive: Whether to search recursively\n\n        Returns:\n            List of matching file paths\n        \"\"\"\n        if not directory.exists():\n            logger.warning(f\"Directory does not exist: {directory}\")\n            return []\n\n        if recursive:\n            return list(directory.rglob(pattern))\n        return list(directory.glob(pattern))\n\n    @staticmethod\n    def get_file_size(path: Path) -&gt; int:\n        \"\"\"Get file size in bytes.\n\n        Args:\n            path: Path to the file\n\n        Returns:\n            File size in bytes, or 0 if file doesn't exist\n        \"\"\"\n        if path.exists():\n            return path.stat().st_size\n        return 0\n\n    @staticmethod\n    def validate_output_path(path: Path, overwrite: bool = False) -&gt; bool:\n        \"\"\"Validate that output path can be written to.\n\n        Args:\n            path: Output file path\n            overwrite: Whether to allow overwriting existing files\n\n        Returns:\n            True if path is valid for writing\n        \"\"\"\n        if path.exists() and not overwrite:\n            logger.warning(f\"Output file already exists: {path}\")\n            return False\n\n        # Ensure parent directory exists\n        FileUtils.ensure_directory(path.parent)\n        return True\n\n    @staticmethod\n    def validate_output_filename(path_str: str) -&gt; tuple[bool, str]:\n        \"\"\"Check if the output filename is valid for video encoding.\n\n        Returns:\n            Tuple of (is_valid, error_message)\n        \"\"\"\n        if not path_str.strip():\n            return False, \"Output path is empty.\"\n\n        path = Path(path_str.strip())\n\n        # Check extension\n        ext = path.suffix.lower().lstrip(\".\")\n        if not ext:\n            return False, \"Output path must have a file extension (e.g., .mp4).\"\n\n        if ext not in constants.SUPPORTED_VIDEO_EXTENSIONS:\n            return (\n                False,\n                f\"Unsupported video extension: .{ext}. Supported: {', '.join(constants.SUPPORTED_VIDEO_EXTENSIONS)}\",\n            )\n\n        # Check for invalid characters in filename (basic check)\n        invalid_chars = '&lt;&gt;:\"|?*'\n        if any(c in path.name for c in invalid_chars):\n            return False, f\"Filename contains invalid characters: {invalid_chars}\"\n\n        return True, \"\"\n</code></pre>"},{"location":"api/io/file_utils/#renderkit.io.file_utils.FileUtils.ensure_directory","title":"<code>ensure_directory(path)</code>  <code>staticmethod</code>","text":"<p>Ensure a directory exists, creating it if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the directory</p> required Source code in <code>src/renderkit/io/file_utils.py</code> <pre><code>@staticmethod\ndef ensure_directory(path: Path) -&gt; None:\n    \"\"\"Ensure a directory exists, creating it if necessary.\n\n    Args:\n        path: Path to the directory\n    \"\"\"\n    path.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/io/file_utils/#renderkit.io.file_utils.FileUtils.find_files_by_pattern","title":"<code>find_files_by_pattern(directory, pattern, recursive=False)</code>  <code>staticmethod</code>","text":"<p>Find files matching a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>Directory to search</p> required <code>pattern</code> <code>str</code> <p>Filename pattern (supports wildcards)</p> required <code>recursive</code> <code>bool</code> <p>Whether to search recursively</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>List of matching file paths</p> Source code in <code>src/renderkit/io/file_utils.py</code> <pre><code>@staticmethod\ndef find_files_by_pattern(directory: Path, pattern: str, recursive: bool = False) -&gt; list[Path]:\n    \"\"\"Find files matching a pattern.\n\n    Args:\n        directory: Directory to search\n        pattern: Filename pattern (supports wildcards)\n        recursive: Whether to search recursively\n\n    Returns:\n        List of matching file paths\n    \"\"\"\n    if not directory.exists():\n        logger.warning(f\"Directory does not exist: {directory}\")\n        return []\n\n    if recursive:\n        return list(directory.rglob(pattern))\n    return list(directory.glob(pattern))\n</code></pre>"},{"location":"api/io/file_utils/#renderkit.io.file_utils.FileUtils.get_file_extension","title":"<code>get_file_extension(path)</code>  <code>staticmethod</code>","text":"<p>Get the file extension (lowercase, without dot).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>str</code> <p>File extension</p> Source code in <code>src/renderkit/io/file_utils.py</code> <pre><code>@staticmethod\ndef get_file_extension(path: Path) -&gt; str:\n    \"\"\"Get the file extension (lowercase, without dot).\n\n    Args:\n        path: Path to the file\n\n    Returns:\n        File extension\n    \"\"\"\n    return path.suffix.lower().lstrip(\".\")\n</code></pre>"},{"location":"api/io/file_utils/#renderkit.io.file_utils.FileUtils.get_file_size","title":"<code>get_file_size(path)</code>  <code>staticmethod</code>","text":"<p>Get file size in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>int</code> <p>File size in bytes, or 0 if file doesn't exist</p> Source code in <code>src/renderkit/io/file_utils.py</code> <pre><code>@staticmethod\ndef get_file_size(path: Path) -&gt; int:\n    \"\"\"Get file size in bytes.\n\n    Args:\n        path: Path to the file\n\n    Returns:\n        File size in bytes, or 0 if file doesn't exist\n    \"\"\"\n    if path.exists():\n        return path.stat().st_size\n    return 0\n</code></pre>"},{"location":"api/io/file_utils/#renderkit.io.file_utils.FileUtils.is_image_file","title":"<code>is_image_file(path)</code>  <code>staticmethod</code>","text":"<p>Check if a file is a supported image format.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if file is a supported image format</p> Source code in <code>src/renderkit/io/file_utils.py</code> <pre><code>@staticmethod\ndef is_image_file(path: Path) -&gt; bool:\n    \"\"\"Check if a file is a supported image format.\n\n    Args:\n        path: Path to the file\n\n    Returns:\n        True if file is a supported image format\n    \"\"\"\n    return FileUtils.get_file_extension(path) in constants.OIIO_SUPPORTED_EXTENSIONS\n</code></pre>"},{"location":"api/io/file_utils/#renderkit.io.file_utils.FileUtils.validate_output_filename","title":"<code>validate_output_filename(path_str)</code>  <code>staticmethod</code>","text":"<p>Check if the output filename is valid for video encoding.</p> <p>Returns:</p> Type Description <code>tuple[bool, str]</code> <p>Tuple of (is_valid, error_message)</p> Source code in <code>src/renderkit/io/file_utils.py</code> <pre><code>@staticmethod\ndef validate_output_filename(path_str: str) -&gt; tuple[bool, str]:\n    \"\"\"Check if the output filename is valid for video encoding.\n\n    Returns:\n        Tuple of (is_valid, error_message)\n    \"\"\"\n    if not path_str.strip():\n        return False, \"Output path is empty.\"\n\n    path = Path(path_str.strip())\n\n    # Check extension\n    ext = path.suffix.lower().lstrip(\".\")\n    if not ext:\n        return False, \"Output path must have a file extension (e.g., .mp4).\"\n\n    if ext not in constants.SUPPORTED_VIDEO_EXTENSIONS:\n        return (\n            False,\n            f\"Unsupported video extension: .{ext}. Supported: {', '.join(constants.SUPPORTED_VIDEO_EXTENSIONS)}\",\n        )\n\n    # Check for invalid characters in filename (basic check)\n    invalid_chars = '&lt;&gt;:\"|?*'\n    if any(c in path.name for c in invalid_chars):\n        return False, f\"Filename contains invalid characters: {invalid_chars}\"\n\n    return True, \"\"\n</code></pre>"},{"location":"api/io/file_utils/#renderkit.io.file_utils.FileUtils.validate_output_path","title":"<code>validate_output_path(path, overwrite=False)</code>  <code>staticmethod</code>","text":"<p>Validate that output path can be written to.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Output file path</p> required <code>overwrite</code> <code>bool</code> <p>Whether to allow overwriting existing files</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if path is valid for writing</p> Source code in <code>src/renderkit/io/file_utils.py</code> <pre><code>@staticmethod\ndef validate_output_path(path: Path, overwrite: bool = False) -&gt; bool:\n    \"\"\"Validate that output path can be written to.\n\n    Args:\n        path: Output file path\n        overwrite: Whether to allow overwriting existing files\n\n    Returns:\n        True if path is valid for writing\n    \"\"\"\n    if path.exists() and not overwrite:\n        logger.warning(f\"Output file already exists: {path}\")\n        return False\n\n    # Ensure parent directory exists\n    FileUtils.ensure_directory(path.parent)\n    return True\n</code></pre>"},{"location":"api/io/image_reader/","title":"Image Reader","text":""},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReader","title":"<code>renderkit.io.image_reader.ImageReader</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for image readers.</p> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>class ImageReader(ABC):\n    \"\"\"Abstract base class for image readers.\"\"\"\n\n    @abstractmethod\n    def read(self, path: Path, layer: Optional[str] = None) -&gt; np.ndarray:\n        \"\"\"Read an image file and return as numpy array.\n\n        Args:\n            path: Path to image file\n            layer: Optional layer name to extract (for multi-layer EXRs)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_layers(self, path: Path) -&gt; list[str]:\n        \"\"\"Get available layers from the image file.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_channels(self, path: Path) -&gt; int:\n        \"\"\"Get the number of channels.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_resolution(self, path: Path) -&gt; tuple[int, int]:\n        \"\"\"Get the resolution (width, height).\"\"\"\n        pass\n\n    @abstractmethod\n    def get_metadata_fps(self, path: Path) -&gt; Optional[float]:\n        \"\"\"Get FPS from metadata.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_metadata_color_space(self, path: Path) -&gt; Optional[str]:\n        \"\"\"Get color space from metadata.\"\"\"\n        pass\n</code></pre>"},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReader.get_channels","title":"<code>get_channels(path)</code>  <code>abstractmethod</code>","text":"<p>Get the number of channels.</p> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>@abstractmethod\ndef get_channels(self, path: Path) -&gt; int:\n    \"\"\"Get the number of channels.\"\"\"\n    pass\n</code></pre>"},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReader.get_layers","title":"<code>get_layers(path)</code>  <code>abstractmethod</code>","text":"<p>Get available layers from the image file.</p> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>@abstractmethod\ndef get_layers(self, path: Path) -&gt; list[str]:\n    \"\"\"Get available layers from the image file.\"\"\"\n    pass\n</code></pre>"},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReader.get_metadata_color_space","title":"<code>get_metadata_color_space(path)</code>  <code>abstractmethod</code>","text":"<p>Get color space from metadata.</p> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>@abstractmethod\ndef get_metadata_color_space(self, path: Path) -&gt; Optional[str]:\n    \"\"\"Get color space from metadata.\"\"\"\n    pass\n</code></pre>"},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReader.get_metadata_fps","title":"<code>get_metadata_fps(path)</code>  <code>abstractmethod</code>","text":"<p>Get FPS from metadata.</p> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>@abstractmethod\ndef get_metadata_fps(self, path: Path) -&gt; Optional[float]:\n    \"\"\"Get FPS from metadata.\"\"\"\n    pass\n</code></pre>"},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReader.get_resolution","title":"<code>get_resolution(path)</code>  <code>abstractmethod</code>","text":"<p>Get the resolution (width, height).</p> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>@abstractmethod\ndef get_resolution(self, path: Path) -&gt; tuple[int, int]:\n    \"\"\"Get the resolution (width, height).\"\"\"\n    pass\n</code></pre>"},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReader.read","title":"<code>read(path, layer=None)</code>  <code>abstractmethod</code>","text":"<p>Read an image file and return as numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to image file</p> required <code>layer</code> <code>Optional[str]</code> <p>Optional layer name to extract (for multi-layer EXRs)</p> <code>None</code> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>@abstractmethod\ndef read(self, path: Path, layer: Optional[str] = None) -&gt; np.ndarray:\n    \"\"\"Read an image file and return as numpy array.\n\n    Args:\n        path: Path to image file\n        layer: Optional layer name to extract (for multi-layer EXRs)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReaderFactory","title":"<code>renderkit.io.image_reader.ImageReaderFactory</code>","text":"<p>Factory for creating appropriate image readers (Now standardized to OIIO).</p> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>class ImageReaderFactory:\n    \"\"\"Factory for creating appropriate image readers (Now standardized to OIIO).\"\"\"\n\n    _readers: dict[str, type[ImageReader]] = {\n        \"exr\": OIIOReader,\n        \"png\": OIIOReader,\n        \"jpg\": OIIOReader,\n        \"jpeg\": OIIOReader,\n        \"tiff\": OIIOReader,\n        \"tif\": OIIOReader,\n        \"dpx\": OIIOReader,\n    }\n\n    @classmethod\n    def create_reader(cls, path: Path) -&gt; ImageReader:\n        \"\"\"Create an OIIO reader for the given file.\"\"\"\n        extension = FileUtils.get_file_extension(path)\n        reader_class = cls._readers.get(extension, OIIOReader)\n        return reader_class()\n\n    @classmethod\n    def register_reader(cls, extension: str, reader_class: type[ImageReader]) -&gt; None:\n        \"\"\"Register a custom image reader.\"\"\"\n        cls._readers[extension.lower()] = reader_class\n</code></pre>"},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReaderFactory.create_reader","title":"<code>create_reader(path)</code>  <code>classmethod</code>","text":"<p>Create an OIIO reader for the given file.</p> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>@classmethod\ndef create_reader(cls, path: Path) -&gt; ImageReader:\n    \"\"\"Create an OIIO reader for the given file.\"\"\"\n    extension = FileUtils.get_file_extension(path)\n    reader_class = cls._readers.get(extension, OIIOReader)\n    return reader_class()\n</code></pre>"},{"location":"api/io/image_reader/#renderkit.io.image_reader.ImageReaderFactory.register_reader","title":"<code>register_reader(extension, reader_class)</code>  <code>classmethod</code>","text":"<p>Register a custom image reader.</p> Source code in <code>src/renderkit/io/image_reader.py</code> <pre><code>@classmethod\ndef register_reader(cls, extension: str, reader_class: type[ImageReader]) -&gt; None:\n    \"\"\"Register a custom image reader.\"\"\"\n    cls._readers[extension.lower()] = reader_class\n</code></pre>"},{"location":"api/processing/color_space/","title":"Color Space","text":""},{"location":"api/processing/color_space/#renderkit.processing.color_space.ColorSpaceConverter","title":"<code>renderkit.processing.color_space.ColorSpaceConverter</code>","text":"<p>Color space converter using Strategy pattern.</p> Source code in <code>src/renderkit/processing/color_space.py</code> <pre><code>class ColorSpaceConverter:\n    \"\"\"Color space converter using Strategy pattern.\"\"\"\n\n    _strategies: dict[ColorSpacePreset, type[ColorSpaceStrategy]] = {\n        ColorSpacePreset.LINEAR_TO_SRGB: LinearToSRGBStrategy,\n        ColorSpacePreset.LINEAR_TO_REC709: LinearToRec709Strategy,\n        ColorSpacePreset.SRGB_TO_LINEAR: SRGBToLinearStrategy,\n        ColorSpacePreset.NO_CONVERSION: NoConversionStrategy,\n        ColorSpacePreset.OCIO_CONVERSION: OCIOColorSpaceStrategy,\n    }\n\n    def __init__(self, preset: ColorSpacePreset = ColorSpacePreset.LINEAR_TO_SRGB):\n        \"\"\"Initialize color space converter.\n\n        Args:\n            preset: Color space conversion preset\n        \"\"\"\n        strategy_class = self._strategies.get(preset)\n        if strategy_class is None:\n            raise ColorSpaceError(f\"Unknown color space preset: {preset}\")\n\n        self._strategy = strategy_class()\n        self._preset = preset\n\n    def convert(self, image: np.ndarray, input_space: Optional[str] = None) -&gt; np.ndarray:\n        \"\"\"Convert image color space.\n\n        Args:\n            image: Input image array (H, W, C) in float32\n            input_space: Optional name of detected input space (used by OCIO strategy)\n\n        Returns:\n            Converted image array\n        \"\"\"\n        return self._strategy.convert(image, input_space=input_space)\n\n    @classmethod\n    def register_strategy(\n        cls, preset: ColorSpacePreset, strategy_class: type[ColorSpaceStrategy]\n    ) -&gt; None:\n        \"\"\"Register a custom color space conversion strategy.\n\n        Args:\n            preset: Color space preset enum\n            strategy_class: Strategy class to register\n        \"\"\"\n        cls._strategies[preset] = strategy_class\n</code></pre>"},{"location":"api/processing/color_space/#renderkit.processing.color_space.ColorSpaceConverter.__init__","title":"<code>__init__(preset=ColorSpacePreset.LINEAR_TO_SRGB)</code>","text":"<p>Initialize color space converter.</p> <p>Parameters:</p> Name Type Description Default <code>preset</code> <code>ColorSpacePreset</code> <p>Color space conversion preset</p> <code>LINEAR_TO_SRGB</code> Source code in <code>src/renderkit/processing/color_space.py</code> <pre><code>def __init__(self, preset: ColorSpacePreset = ColorSpacePreset.LINEAR_TO_SRGB):\n    \"\"\"Initialize color space converter.\n\n    Args:\n        preset: Color space conversion preset\n    \"\"\"\n    strategy_class = self._strategies.get(preset)\n    if strategy_class is None:\n        raise ColorSpaceError(f\"Unknown color space preset: {preset}\")\n\n    self._strategy = strategy_class()\n    self._preset = preset\n</code></pre>"},{"location":"api/processing/color_space/#renderkit.processing.color_space.ColorSpaceConverter.convert","title":"<code>convert(image, input_space=None)</code>","text":"<p>Convert image color space.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Input image array (H, W, C) in float32</p> required <code>input_space</code> <code>Optional[str]</code> <p>Optional name of detected input space (used by OCIO strategy)</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Converted image array</p> Source code in <code>src/renderkit/processing/color_space.py</code> <pre><code>def convert(self, image: np.ndarray, input_space: Optional[str] = None) -&gt; np.ndarray:\n    \"\"\"Convert image color space.\n\n    Args:\n        image: Input image array (H, W, C) in float32\n        input_space: Optional name of detected input space (used by OCIO strategy)\n\n    Returns:\n        Converted image array\n    \"\"\"\n    return self._strategy.convert(image, input_space=input_space)\n</code></pre>"},{"location":"api/processing/color_space/#renderkit.processing.color_space.ColorSpaceConverter.register_strategy","title":"<code>register_strategy(preset, strategy_class)</code>  <code>classmethod</code>","text":"<p>Register a custom color space conversion strategy.</p> <p>Parameters:</p> Name Type Description Default <code>preset</code> <code>ColorSpacePreset</code> <p>Color space preset enum</p> required <code>strategy_class</code> <code>type[ColorSpaceStrategy]</code> <p>Strategy class to register</p> required Source code in <code>src/renderkit/processing/color_space.py</code> <pre><code>@classmethod\ndef register_strategy(\n    cls, preset: ColorSpacePreset, strategy_class: type[ColorSpaceStrategy]\n) -&gt; None:\n    \"\"\"Register a custom color space conversion strategy.\n\n    Args:\n        preset: Color space preset enum\n        strategy_class: Strategy class to register\n    \"\"\"\n    cls._strategies[preset] = strategy_class\n</code></pre>"},{"location":"api/processing/color_space/#renderkit.processing.color_space.ColorSpacePreset","title":"<code>renderkit.processing.color_space.ColorSpacePreset</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Color space conversion presets.</p> Source code in <code>src/renderkit/processing/color_space.py</code> <pre><code>class ColorSpacePreset(Enum):\n    \"\"\"Color space conversion presets.\"\"\"\n\n    LINEAR_TO_SRGB = \"linear_to_srgb\"\n    LINEAR_TO_REC709 = \"linear_to_rec709\"\n    SRGB_TO_LINEAR = \"srgb_to_linear\"\n    NO_CONVERSION = \"no_conversion\"\n    OCIO_CONVERSION = \"ocio_conversion\"\n</code></pre>"},{"location":"api/processing/contact_sheet/","title":"Contact Sheet Generation","text":""},{"location":"api/processing/contact_sheet/#renderkit.processing.contact_sheet.ContactSheetGenerator","title":"<code>renderkit.processing.contact_sheet.ContactSheetGenerator</code>","text":"<p>Generates a composite grid of all AOVs (layers) for a single image frame.</p> Source code in <code>src/renderkit/processing/contact_sheet.py</code> <pre><code>class ContactSheetGenerator:\n    \"\"\"Generates a composite grid of all AOVs (layers) for a single image frame.\"\"\"\n\n    def __init__(self, config: ContactSheetConfig) -&gt; None:\n        \"\"\"Initialize generator.\n\n        Args:\n            config: Contact sheet layout configuration\n        \"\"\"\n        self.config = config\n\n    def composite_layers(self, frame_path: Path) -&gt; oiio.ImageBuf:\n        \"\"\"Composite all layers of a frame into a grid.\n\n        Args:\n            frame_path: Path to the image file (e.g. EXR)\n\n        Returns:\n            ImageBuf containing the composited grid\n        \"\"\"\n        reader = ImageReaderFactory.create_reader(frame_path)\n        layers = reader.get_layers(frame_path)\n\n        if not layers:\n            # Fallback to just reading the image if no layers detected\n            return oiio.ImageBuf(str(frame_path))\n\n        # Calculate grid dimensions\n        num_layers = len(layers)\n        cols = self.config.columns\n        rows = (num_layers + cols - 1) // cols\n\n        thumb_w = self.config.thumbnail_width\n        padding = self.config.padding\n\n        # We'll calculate thumb_h based on the first layer's aspect ratio\n        first_pixels = reader.read(frame_path, layer=layers[0])\n        h, w = first_pixels.shape[:2]\n        aspect = h / w\n        thumb_h = int(thumb_w * aspect)\n\n        # Label height\n        label_h = 0\n        if self.config.show_labels:\n            label_h = int(self.config.font_size * 2.5)\n\n        cell_w = thumb_w + (padding * 2)\n        cell_h = thumb_h + (padding * 2) + label_h\n\n        canvas_w = cell_w * cols\n        canvas_h = cell_h * rows\n\n        # Create canvas\n        canvas_spec = oiio.ImageSpec(canvas_w, canvas_h, 3, oiio.FLOAT)\n        canvas = oiio.ImageBuf(canvas_spec)\n        oiio.ImageBufAlgo.fill(canvas, self.config.background_color)\n\n        # Process each layer\n        for i, layer_name in enumerate(layers):\n            row = i // cols\n            col = i % cols\n\n            x_offset = col * cell_w + padding\n            y_offset = row * cell_h + padding\n\n            try:\n                # Read layer\n                layer_pixels = reader.read(frame_path, layer=layer_name)\n\n                # Resize to thumbnail\n                scaled_buf = self._scale_to_thumbnail(layer_pixels, thumb_w, thumb_h)\n\n                # Paste onto canvas\n                oiio.ImageBufAlgo.paste(canvas, x_offset, y_offset, 0, 0, scaled_buf)\n\n                # Add label\n                if self.config.show_labels:\n                    label_x = x_offset\n                    label_y = y_offset + thumb_h + 5\n                    oiio.ImageBufAlgo.render_text(\n                        canvas,\n                        label_x,\n                        label_y,\n                        layer_name,\n                        fontsize=self.config.font_size,\n                        textcolor=(1, 1, 1, 1),\n                    )\n            except Exception as e:\n                logger.error(f\"Failed to process layer {layer_name} for contact sheet: {e}\")\n\n        return canvas\n\n    def _scale_to_thumbnail(self, pixels: np.ndarray, width: int, height: int) -&gt; oiio.ImageBuf:\n        \"\"\"Scale pixel data to thumbnail dimensions and return as ImageBuf.\"\"\"\n        scaled_pixels = ImageScaler.scale_image(pixels, width=width, height=height)\n\n        # Convert back to ImageBuf\n        channels = scaled_pixels.shape[2] if scaled_pixels.ndim == 3 else 1\n        spec = oiio.ImageSpec(width, height, channels, oiio.FLOAT)\n        scaled_buf = oiio.ImageBuf(spec)\n        scaled_buf.set_pixels(oiio.ROI(), scaled_pixels.astype(np.float32))\n        return scaled_buf\n</code></pre>"},{"location":"api/processing/contact_sheet/#renderkit.processing.contact_sheet.ContactSheetGenerator.__init__","title":"<code>__init__(config)</code>","text":"<p>Initialize generator.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ContactSheetConfig</code> <p>Contact sheet layout configuration</p> required Source code in <code>src/renderkit/processing/contact_sheet.py</code> <pre><code>def __init__(self, config: ContactSheetConfig) -&gt; None:\n    \"\"\"Initialize generator.\n\n    Args:\n        config: Contact sheet layout configuration\n    \"\"\"\n    self.config = config\n</code></pre>"},{"location":"api/processing/contact_sheet/#renderkit.processing.contact_sheet.ContactSheetGenerator.composite_layers","title":"<code>composite_layers(frame_path)</code>","text":"<p>Composite all layers of a frame into a grid.</p> <p>Parameters:</p> Name Type Description Default <code>frame_path</code> <code>Path</code> <p>Path to the image file (e.g. EXR)</p> required <p>Returns:</p> Type Description <code>ImageBuf</code> <p>ImageBuf containing the composited grid</p> Source code in <code>src/renderkit/processing/contact_sheet.py</code> <pre><code>def composite_layers(self, frame_path: Path) -&gt; oiio.ImageBuf:\n    \"\"\"Composite all layers of a frame into a grid.\n\n    Args:\n        frame_path: Path to the image file (e.g. EXR)\n\n    Returns:\n        ImageBuf containing the composited grid\n    \"\"\"\n    reader = ImageReaderFactory.create_reader(frame_path)\n    layers = reader.get_layers(frame_path)\n\n    if not layers:\n        # Fallback to just reading the image if no layers detected\n        return oiio.ImageBuf(str(frame_path))\n\n    # Calculate grid dimensions\n    num_layers = len(layers)\n    cols = self.config.columns\n    rows = (num_layers + cols - 1) // cols\n\n    thumb_w = self.config.thumbnail_width\n    padding = self.config.padding\n\n    # We'll calculate thumb_h based on the first layer's aspect ratio\n    first_pixels = reader.read(frame_path, layer=layers[0])\n    h, w = first_pixels.shape[:2]\n    aspect = h / w\n    thumb_h = int(thumb_w * aspect)\n\n    # Label height\n    label_h = 0\n    if self.config.show_labels:\n        label_h = int(self.config.font_size * 2.5)\n\n    cell_w = thumb_w + (padding * 2)\n    cell_h = thumb_h + (padding * 2) + label_h\n\n    canvas_w = cell_w * cols\n    canvas_h = cell_h * rows\n\n    # Create canvas\n    canvas_spec = oiio.ImageSpec(canvas_w, canvas_h, 3, oiio.FLOAT)\n    canvas = oiio.ImageBuf(canvas_spec)\n    oiio.ImageBufAlgo.fill(canvas, self.config.background_color)\n\n    # Process each layer\n    for i, layer_name in enumerate(layers):\n        row = i // cols\n        col = i % cols\n\n        x_offset = col * cell_w + padding\n        y_offset = row * cell_h + padding\n\n        try:\n            # Read layer\n            layer_pixels = reader.read(frame_path, layer=layer_name)\n\n            # Resize to thumbnail\n            scaled_buf = self._scale_to_thumbnail(layer_pixels, thumb_w, thumb_h)\n\n            # Paste onto canvas\n            oiio.ImageBufAlgo.paste(canvas, x_offset, y_offset, 0, 0, scaled_buf)\n\n            # Add label\n            if self.config.show_labels:\n                label_x = x_offset\n                label_y = y_offset + thumb_h + 5\n                oiio.ImageBufAlgo.render_text(\n                    canvas,\n                    label_x,\n                    label_y,\n                    layer_name,\n                    fontsize=self.config.font_size,\n                    textcolor=(1, 1, 1, 1),\n                )\n        except Exception as e:\n            logger.error(f\"Failed to process layer {layer_name} for contact sheet: {e}\")\n\n    return canvas\n</code></pre>"},{"location":"api/processing/scaler/","title":"Image Scaler","text":""},{"location":"api/processing/scaler/#renderkit.processing.scaler.ImageScaler","title":"<code>renderkit.processing.scaler.ImageScaler</code>","text":"<p>Utility class for image scaling using OpenImageIO.</p> Source code in <code>src/renderkit/processing/scaler.py</code> <pre><code>class ImageScaler:\n    \"\"\"Utility class for image scaling using OpenImageIO.\"\"\"\n\n    @staticmethod\n    def scale_image(\n        image: np.ndarray,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        filter_name: str = \"lanczos3\",\n    ) -&gt; np.ndarray:\n        \"\"\"Scale an image to the specified dimensions using OIIO.\n\n        Args:\n            image: Input image array (H, W, C)\n            width: Target width\n            height: Target height\n            filter_name: OIIO filter name (e.g., 'lanczos3', 'mitchell', 'catmull-rom')\n\n        Returns:\n            Scaled image array\n        \"\"\"\n        try:\n            import OpenImageIO as oiio\n        except ImportError as e:\n            raise RuntimeError(\"OpenImageIO library not available.\") from e\n\n        if width is None and height is None:\n            raise ValueError(\"At least one of width or height must be specified\")\n\n        h, w = image.shape[:2]\n        channels = image.shape[2] if len(image.shape) == 3 else 1\n\n        # Calculate target dimensions\n        if width is not None and height is not None:\n            target_w, target_h = width, height\n        elif width is not None:\n            aspect_ratio = h / w\n            target_w = width\n            target_h = int(width * aspect_ratio)\n        else:\n            aspect_ratio = w / h\n            target_h = height\n            target_w = int(height * aspect_ratio)\n\n        # No scaling needed if dimensions match\n        if target_w == w and target_h == h:\n            return image\n\n        # Create OIIO ImageBuf from numpy array\n        # Note: image might be float32 or uint8. OIIO handles both.\n        src_buf = oiio.ImageBuf(oiio.ImageSpec(w, h, channels, oiio.FLOAT))\n        src_buf.set_pixels(oiio.ROI(), image.astype(np.float32))\n\n        # Create destination buffer\n        dst_buf = oiio.ImageBuf(oiio.ImageSpec(target_w, target_h, channels, oiio.FLOAT))\n\n        # Perform the resize\n        if not oiio.ImageBufAlgo.resize(dst_buf, src_buf, filtername=filter_name):\n            raise RuntimeError(f\"OIIO resize failed: {oiio.geterror()}\")\n\n        # Convert back to numpy\n        scaled = dst_buf.get_pixels(oiio.FLOAT)\n        scaled = scaled.reshape((target_h, target_w, channels))\n\n        # Cast back to original type if needed (though our pipeline mostly uses float32)\n        if image.dtype == np.uint8:\n            scaled = (np.clip(scaled, 0.0, 1.0) * 255.0).astype(np.uint8)\n\n        return scaled\n\n    @staticmethod\n    def scale_to_fit(\n        image: np.ndarray,\n        max_width: int,\n        max_height: int,\n        filter_name: str = \"lanczos3\",\n    ) -&gt; np.ndarray:\n        \"\"\"Scale image to fit within maximum dimensions while maintaining aspect ratio.\"\"\"\n        h, w = image.shape[:2]\n\n        # Calculate scaling factor\n        scale_w = max_width / w if w &gt; max_width else 1.0\n        scale_h = max_height / h if h &gt; max_height else 1.0\n        scale = min(scale_w, scale_h)\n\n        # If no scaling needed\n        if scale &gt;= 1.0:\n            return image\n\n        target_w = int(w * scale)\n        target_h = int(h * scale)\n\n        return ImageScaler.scale_image(image, target_w, target_h, filter_name)\n</code></pre>"},{"location":"api/processing/scaler/#renderkit.processing.scaler.ImageScaler.scale_image","title":"<code>scale_image(image, width=None, height=None, filter_name='lanczos3')</code>  <code>staticmethod</code>","text":"<p>Scale an image to the specified dimensions using OIIO.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Input image array (H, W, C)</p> required <code>width</code> <code>Optional[int]</code> <p>Target width</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>Target height</p> <code>None</code> <code>filter_name</code> <code>str</code> <p>OIIO filter name (e.g., 'lanczos3', 'mitchell', 'catmull-rom')</p> <code>'lanczos3'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Scaled image array</p> Source code in <code>src/renderkit/processing/scaler.py</code> <pre><code>@staticmethod\ndef scale_image(\n    image: np.ndarray,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    filter_name: str = \"lanczos3\",\n) -&gt; np.ndarray:\n    \"\"\"Scale an image to the specified dimensions using OIIO.\n\n    Args:\n        image: Input image array (H, W, C)\n        width: Target width\n        height: Target height\n        filter_name: OIIO filter name (e.g., 'lanczos3', 'mitchell', 'catmull-rom')\n\n    Returns:\n        Scaled image array\n    \"\"\"\n    try:\n        import OpenImageIO as oiio\n    except ImportError as e:\n        raise RuntimeError(\"OpenImageIO library not available.\") from e\n\n    if width is None and height is None:\n        raise ValueError(\"At least one of width or height must be specified\")\n\n    h, w = image.shape[:2]\n    channels = image.shape[2] if len(image.shape) == 3 else 1\n\n    # Calculate target dimensions\n    if width is not None and height is not None:\n        target_w, target_h = width, height\n    elif width is not None:\n        aspect_ratio = h / w\n        target_w = width\n        target_h = int(width * aspect_ratio)\n    else:\n        aspect_ratio = w / h\n        target_h = height\n        target_w = int(height * aspect_ratio)\n\n    # No scaling needed if dimensions match\n    if target_w == w and target_h == h:\n        return image\n\n    # Create OIIO ImageBuf from numpy array\n    # Note: image might be float32 or uint8. OIIO handles both.\n    src_buf = oiio.ImageBuf(oiio.ImageSpec(w, h, channels, oiio.FLOAT))\n    src_buf.set_pixels(oiio.ROI(), image.astype(np.float32))\n\n    # Create destination buffer\n    dst_buf = oiio.ImageBuf(oiio.ImageSpec(target_w, target_h, channels, oiio.FLOAT))\n\n    # Perform the resize\n    if not oiio.ImageBufAlgo.resize(dst_buf, src_buf, filtername=filter_name):\n        raise RuntimeError(f\"OIIO resize failed: {oiio.geterror()}\")\n\n    # Convert back to numpy\n    scaled = dst_buf.get_pixels(oiio.FLOAT)\n    scaled = scaled.reshape((target_h, target_w, channels))\n\n    # Cast back to original type if needed (though our pipeline mostly uses float32)\n    if image.dtype == np.uint8:\n        scaled = (np.clip(scaled, 0.0, 1.0) * 255.0).astype(np.uint8)\n\n    return scaled\n</code></pre>"},{"location":"api/processing/scaler/#renderkit.processing.scaler.ImageScaler.scale_to_fit","title":"<code>scale_to_fit(image, max_width, max_height, filter_name='lanczos3')</code>  <code>staticmethod</code>","text":"<p>Scale image to fit within maximum dimensions while maintaining aspect ratio.</p> Source code in <code>src/renderkit/processing/scaler.py</code> <pre><code>@staticmethod\ndef scale_to_fit(\n    image: np.ndarray,\n    max_width: int,\n    max_height: int,\n    filter_name: str = \"lanczos3\",\n) -&gt; np.ndarray:\n    \"\"\"Scale image to fit within maximum dimensions while maintaining aspect ratio.\"\"\"\n    h, w = image.shape[:2]\n\n    # Calculate scaling factor\n    scale_w = max_width / w if w &gt; max_width else 1.0\n    scale_h = max_height / h if h &gt; max_height else 1.0\n    scale = min(scale_w, scale_h)\n\n    # If no scaling needed\n    if scale &gt;= 1.0:\n        return image\n\n    target_w = int(w * scale)\n    target_h = int(h * scale)\n\n    return ImageScaler.scale_image(image, target_w, target_h, filter_name)\n</code></pre>"},{"location":"api/processing/video_encoder/","title":"Video Encoder","text":""},{"location":"api/processing/video_encoder/#renderkit.processing.video_encoder.VideoEncoder","title":"<code>renderkit.processing.video_encoder.VideoEncoder</code>","text":"<p>Video encoder for creating MP4 files using FFmpeg.</p> Source code in <code>src/renderkit/processing/video_encoder.py</code> <pre><code>class VideoEncoder:\n    \"\"\"Video encoder for creating MP4 files using FFmpeg.\"\"\"\n\n    def __init__(\n        self,\n        output_path: Path,\n        fps: float,\n        codec: str = \"libx264\",\n        bitrate: Optional[int] = None,\n        quality: Optional[int] = 10,\n        macro_block_size: int = 16,\n    ) -&gt; None:\n        \"\"\"Initialize video encoder.\n\n        Args:\n            output_path: Path to output video file\n            fps: Frame rate\n            codec: Video codec (FFmpeg name like 'libx264', 'libx265', 'libaom-av1')\n            bitrate: Video bitrate in kbps (optional)\n            quality: Video quality (0-10), 10 is best (optional, used if bitrate is None)\n            macro_block_size: Macro block size for codec compatibility (default: 16)\n                             Frame dimensions will be rounded up to multiples of this value\n        \"\"\"\n        self.output_path = output_path.absolute()\n        self.fps = fps\n        self.codec = codec\n        self.bitrate = bitrate\n        self.quality = quality\n        self.macro_block_size = macro_block_size\n        self._writer = None\n        self._width: Optional[int] = None\n        self._height: Optional[int] = None\n        self._adjusted_width: Optional[int] = None\n        self._adjusted_height: Optional[int] = None\n        self._ffmpeg_report_path: Optional[Path] = None\n        self._ffreport_prev: Optional[str] = None\n        self._ffreport_set: bool = False\n\n    def _configure_ffmpeg_report(self) -&gt; Optional[Path]:\n        \"\"\"Enable ffmpeg report logging (on by default).\"\"\"\n        value = os.environ.get(\"RENDERKIT_FFMPEG_LOG\", \"1\")\n        if value.lower() in {\"0\", \"false\", \"no\", \"off\"}:\n            return None\n        if value.lower() in {\"1\", \"true\", \"yes\", \"on\"}:\n            stamp = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n            path = Path(tempfile.gettempdir()) / f\"renderkit-ffmpeg-{stamp}.log\"\n        else:\n            path = Path(value).expanduser()\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        if \"FFREPORT\" in os.environ:\n            self._ffreport_prev = os.environ[\"FFREPORT\"]\n        else:\n            self._ffreport_prev = None\n        escaped_path = _escape_ffreport_path(path)\n        os.environ[\"FFREPORT\"] = f\"file={escaped_path}:level=48\"\n        self._ffreport_set = True\n        return path\n\n    def _restore_ffmpeg_report_env(self) -&gt; None:\n        if not self._ffreport_set:\n            return\n        if self._ffreport_prev is None:\n            os.environ.pop(\"FFREPORT\", None)\n        else:\n            os.environ[\"FFREPORT\"] = self._ffreport_prev\n        self._ffreport_set = False\n\n    def _read_ffmpeg_report_tail(self, max_lines: int = 80) -&gt; Optional[str]:\n        if self._ffmpeg_report_path is None:\n            return None\n        if not self._ffmpeg_report_path.exists():\n            return None\n        try:\n            content = self._ffmpeg_report_path.read_text(errors=\"ignore\")\n        except Exception:\n            return None\n        lines = [line for line in content.splitlines() if line.strip()]\n        if not lines:\n            return None\n        tail = \"\\n\".join(lines[-max_lines:])\n        return f\"FFMPEG REPORT (tail) [{self._ffmpeg_report_path}]:\\n{tail}\"\n\n    @staticmethod\n    def _make_divisible(dimension: int, divisor: int = 16) -&gt; int:\n        \"\"\"Round up dimension to be divisible by divisor for codec compatibility.\n\n        Args:\n            dimension: Original dimension\n            divisor: Divisor (typically 16 for macro block size)\n\n        Returns:\n            Dimension rounded up to nearest multiple of divisor\n        \"\"\"\n        return ((dimension + divisor - 1) // divisor) * divisor\n\n    def __enter__(self) -&gt; \"VideoEncoder\":\n        \"\"\"Context manager entry.\"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Context manager exit - close video writer.\"\"\"\n        self.close()\n\n    def initialize(self, width: int, height: int) -&gt; None:\n        \"\"\"Initialize the video writer with frame dimensions.\n\n        Args:\n            width: Frame width\n            height: Frame height\n\n        Raises:\n            VideoEncodingError: If encoder cannot be initialized\n        \"\"\"\n        self._width = width\n        self._height = height\n\n        # Adjust dimensions to be divisible by macro_block_size for codec compatibility\n        # This prevents ffmpeg from needing to auto-resize frames.\n        self._adjusted_width = self._make_divisible(width, self.macro_block_size)\n        self._adjusted_height = self._make_divisible(height, self.macro_block_size)\n\n        if self._adjusted_width != width or self._adjusted_height != height:\n            logger.warning(\n                f\"Frame dimensions adjusted from {width}x{height} to \"\n                f\"{self._adjusted_width}x{self._adjusted_height} for codec compatibility\"\n            )\n\n        # Ensure output directory exists\n        self.output_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Map UI/OpenCV-style codecs to FFmpeg codecs\n        codec_map = {\n            \"avc1\": \"libx264\",\n            \"hevc\": \"libx265\",\n            \"mp4v\": \"mpeg4\",\n            \"XVID\": \"mpeg4\",\n        }\n        ffmpeg_codec = codec_map.get(self.codec, self.codec)\n        available_encoders = get_available_encoders()\n        ffmpeg_codec, fallback_warning = select_available_encoder(ffmpeg_codec, available_encoders)\n        if fallback_warning:\n            logger.warning(fallback_warning)\n        if available_encoders and ffmpeg_codec not in available_encoders:\n            available = \", \".join(sorted(available_encoders))\n            raise VideoEncodingError(\n                f\"Requested FFmpeg encoder '{ffmpeg_codec}' is not available. \"\n                f\"Available encoders: {available}\"\n            )\n\n        ffmpeg_log_level = \"warning\"\n        self._ffmpeg_report_path = self._configure_ffmpeg_report()\n        if self._ffmpeg_report_path is not None:\n            ffmpeg_log_level = \"info\"\n            logger.info(\"Logging to file: %s\", self._ffmpeg_report_path)\n\n        # Set default FFmpeg parameters for broad compatibility and web optimization\n        # -movflags +faststart enables progressive loading for web playback\n        # Add explicit SDR color tags for predictable playback across platforms\n        ffmpeg_params = [\n            \"-movflags\",\n            \"+faststart\",\n            \"-color_primaries\",\n            \"bt709\",\n            \"-color_trc\",\n            \"bt709\",\n            \"-colorspace\",\n            \"bt709\",\n        ]\n\n        bitrate: Optional[str] = None\n\n        # Codec-specific tuning and quality mapping\n        if ffmpeg_codec in [\"libx264\", \"libx265\"]:\n            # Map quality (0-10) to CRF (35-18)\n            # 10 -&gt; 18 (Excellent), 0 -&gt; 35 (Low quality)\n            # Default to 23 if not specified\n            crf = 18 + (10 - self.quality) * 1.7 if self.quality is not None else 23\n            ffmpeg_params.extend([\"-crf\", f\"{int(crf)}\"])\n            logger.debug(f\"{ffmpeg_codec} tuning: crf={int(crf)}\")\n\n        elif ffmpeg_codec == \"libaom-av1\":\n            # AV1 is extremely slow by default. Use -cpu-used 6 for better speed.\n            # Map 0-10 quality to CRF 50-20 (lower is better)\n            crf = 20 + (10 - self.quality) * 3 if self.quality is not None else 32\n            ffmpeg_params.extend([\"-crf\", f\"{int(crf)}\", \"-cpu-used\", \"6\"])\n            # libaom-av1 needs bitrate=0 to enable CRF mode in FFmpeg\n            bitrate = \"0\"\n            logger.debug(f\"AV1 tuning: crf={int(crf)}, cpu-used=6\")\n\n        elif ffmpeg_codec == \"mpeg4\":\n            # Map quality (0-10) to -q:v (31-2)\n            # Higher -q:v is lower quality.\n            qv = 2 + (10 - self.quality) * 2.9 if self.quality is not None else 4\n            ffmpeg_params.extend([\"-q:v\", f\"{int(qv)}\"])\n            logger.debug(f\"MPEG-4 tuning: q:v={int(qv)}\")\n\n        elif self.bitrate:\n            bitrate = f\"{self.bitrate}k\"\n\n        # Apply final FFmpeg parameters\n        if self._ffmpeg_report_path is not None:\n            ffmpeg_params.extend([\"-report\", \"-loglevel\", \"info\"])\n        try:\n            self._writer = _RawFfmpegPipeWriter(\n                self.output_path,\n                self._adjusted_width,\n                self._adjusted_height,\n                self.fps,\n                ffmpeg_codec,\n                \"rgb24\",\n                \"yuv420p\",\n                ffmpeg_params,\n                ffmpeg_log_level,\n                bitrate,\n            )\n            logger.debug(\n                f\"Initialized FFmpeg pipe writer: {width}x{height} @ {self.fps}fps, \"\n                f\"codec={ffmpeg_codec}, quality={self.quality}, params={ffmpeg_params}\"\n            )\n        except RuntimeError as e:\n            msg = str(e)\n            self._restore_ffmpeg_report_env()\n            if \"ffmpeg\" in msg.lower():\n                raise VideoEncodingError(\n                    \"FFmpeg backend not found. Please install imageio-ffmpeg: 'pip install imageio-ffmpeg'\"\n                ) from e\n            raise VideoEncodingError(f\"Failed to initialize video encoder: {e}\") from e\n        except Exception as e:\n            self._restore_ffmpeg_report_env()\n            raise VideoEncodingError(f\"Failed to initialize video encoder: {e}\") from e\n\n    def write_frame(self, frame: np.ndarray) -&gt; None:\n        \"\"\"Write a frame to the video.\n\n        Args:\n            frame: Frame as numpy array (H, W, C) in uint8 or float32 format\n        \"\"\"\n        if self._writer is None:\n            raise VideoEncodingError(\"Video encoder not initialized. Call initialize() first.\")\n\n        # Resize frame if needed to match adjusted dimensions\n        # This ensures all frames have consistent size for video encoding\n        if frame.shape[1] != self._adjusted_width or frame.shape[0] != self._adjusted_height:\n            frame = ImageScaler.scale_image(\n                frame,\n                width=self._adjusted_width,\n                height=self._adjusted_height,\n                filter_name=\"lanczos3\",\n            )\n\n        # Ensure frame is uint8 [0, 255] for FFmpeg rawvideo\n        if frame.dtype != np.uint8:\n            frame = np.clip(frame * 255.0, 0, 255).astype(np.uint8)\n\n        # FFmpeg rawvideo expects RGB (standard)\n        # If RGBA, drop alpha channel\n        if len(frame.shape) == 3 and frame.shape[2] == 4:\n            frame = frame[:, :, :3]\n        # If Grayscale, ensure 3D\n        elif len(frame.shape) == 2:\n            frame = np.stack([frame] * 3, axis=-1)\n\n        try:\n            self._writer.append_data(frame)\n        except Exception as e:\n            report_tail = self._read_ffmpeg_report_tail()\n            if report_tail:\n                raise VideoEncodingError(\n                    f\"Failed to write frame to video: {e}\\n\\n{report_tail}\"\n                ) from e\n            raise VideoEncodingError(f\"Failed to write frame to video: {e}\") from e\n\n    def close(self) -&gt; None:\n        \"\"\"Close the video writer.\"\"\"\n        if self._writer is not None:\n            try:\n                self._writer.close()\n                logger.info(\"Video encoding completed.\")\n            except Exception as e:\n                logger.error(f\"Error closing video writer: {e}\")\n            finally:\n                self._writer = None\n        self._restore_ffmpeg_report_env()\n\n    def is_initialized(self) -&gt; bool:\n        \"\"\"Check if encoder is initialized.\"\"\"\n        return self._writer is not None\n</code></pre>"},{"location":"api/processing/video_encoder/#renderkit.processing.video_encoder.VideoEncoder.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/renderkit/processing/video_encoder.py</code> <pre><code>def __enter__(self) -&gt; \"VideoEncoder\":\n    \"\"\"Context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"api/processing/video_encoder/#renderkit.processing.video_encoder.VideoEncoder.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit - close video writer.</p> Source code in <code>src/renderkit/processing/video_encoder.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Context manager exit - close video writer.\"\"\"\n    self.close()\n</code></pre>"},{"location":"api/processing/video_encoder/#renderkit.processing.video_encoder.VideoEncoder.__init__","title":"<code>__init__(output_path, fps, codec='libx264', bitrate=None, quality=10, macro_block_size=16)</code>","text":"<p>Initialize video encoder.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>Path</code> <p>Path to output video file</p> required <code>fps</code> <code>float</code> <p>Frame rate</p> required <code>codec</code> <code>str</code> <p>Video codec (FFmpeg name like 'libx264', 'libx265', 'libaom-av1')</p> <code>'libx264'</code> <code>bitrate</code> <code>Optional[int]</code> <p>Video bitrate in kbps (optional)</p> <code>None</code> <code>quality</code> <code>Optional[int]</code> <p>Video quality (0-10), 10 is best (optional, used if bitrate is None)</p> <code>10</code> <code>macro_block_size</code> <code>int</code> <p>Macro block size for codec compatibility (default: 16)              Frame dimensions will be rounded up to multiples of this value</p> <code>16</code> Source code in <code>src/renderkit/processing/video_encoder.py</code> <pre><code>def __init__(\n    self,\n    output_path: Path,\n    fps: float,\n    codec: str = \"libx264\",\n    bitrate: Optional[int] = None,\n    quality: Optional[int] = 10,\n    macro_block_size: int = 16,\n) -&gt; None:\n    \"\"\"Initialize video encoder.\n\n    Args:\n        output_path: Path to output video file\n        fps: Frame rate\n        codec: Video codec (FFmpeg name like 'libx264', 'libx265', 'libaom-av1')\n        bitrate: Video bitrate in kbps (optional)\n        quality: Video quality (0-10), 10 is best (optional, used if bitrate is None)\n        macro_block_size: Macro block size for codec compatibility (default: 16)\n                         Frame dimensions will be rounded up to multiples of this value\n    \"\"\"\n    self.output_path = output_path.absolute()\n    self.fps = fps\n    self.codec = codec\n    self.bitrate = bitrate\n    self.quality = quality\n    self.macro_block_size = macro_block_size\n    self._writer = None\n    self._width: Optional[int] = None\n    self._height: Optional[int] = None\n    self._adjusted_width: Optional[int] = None\n    self._adjusted_height: Optional[int] = None\n    self._ffmpeg_report_path: Optional[Path] = None\n    self._ffreport_prev: Optional[str] = None\n    self._ffreport_set: bool = False\n</code></pre>"},{"location":"api/processing/video_encoder/#renderkit.processing.video_encoder.VideoEncoder.close","title":"<code>close()</code>","text":"<p>Close the video writer.</p> Source code in <code>src/renderkit/processing/video_encoder.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the video writer.\"\"\"\n    if self._writer is not None:\n        try:\n            self._writer.close()\n            logger.info(\"Video encoding completed.\")\n        except Exception as e:\n            logger.error(f\"Error closing video writer: {e}\")\n        finally:\n            self._writer = None\n    self._restore_ffmpeg_report_env()\n</code></pre>"},{"location":"api/processing/video_encoder/#renderkit.processing.video_encoder.VideoEncoder.initialize","title":"<code>initialize(width, height)</code>","text":"<p>Initialize the video writer with frame dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Frame width</p> required <code>height</code> <code>int</code> <p>Frame height</p> required <p>Raises:</p> Type Description <code>VideoEncodingError</code> <p>If encoder cannot be initialized</p> Source code in <code>src/renderkit/processing/video_encoder.py</code> <pre><code>def initialize(self, width: int, height: int) -&gt; None:\n    \"\"\"Initialize the video writer with frame dimensions.\n\n    Args:\n        width: Frame width\n        height: Frame height\n\n    Raises:\n        VideoEncodingError: If encoder cannot be initialized\n    \"\"\"\n    self._width = width\n    self._height = height\n\n    # Adjust dimensions to be divisible by macro_block_size for codec compatibility\n    # This prevents ffmpeg from needing to auto-resize frames.\n    self._adjusted_width = self._make_divisible(width, self.macro_block_size)\n    self._adjusted_height = self._make_divisible(height, self.macro_block_size)\n\n    if self._adjusted_width != width or self._adjusted_height != height:\n        logger.warning(\n            f\"Frame dimensions adjusted from {width}x{height} to \"\n            f\"{self._adjusted_width}x{self._adjusted_height} for codec compatibility\"\n        )\n\n    # Ensure output directory exists\n    self.output_path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Map UI/OpenCV-style codecs to FFmpeg codecs\n    codec_map = {\n        \"avc1\": \"libx264\",\n        \"hevc\": \"libx265\",\n        \"mp4v\": \"mpeg4\",\n        \"XVID\": \"mpeg4\",\n    }\n    ffmpeg_codec = codec_map.get(self.codec, self.codec)\n    available_encoders = get_available_encoders()\n    ffmpeg_codec, fallback_warning = select_available_encoder(ffmpeg_codec, available_encoders)\n    if fallback_warning:\n        logger.warning(fallback_warning)\n    if available_encoders and ffmpeg_codec not in available_encoders:\n        available = \", \".join(sorted(available_encoders))\n        raise VideoEncodingError(\n            f\"Requested FFmpeg encoder '{ffmpeg_codec}' is not available. \"\n            f\"Available encoders: {available}\"\n        )\n\n    ffmpeg_log_level = \"warning\"\n    self._ffmpeg_report_path = self._configure_ffmpeg_report()\n    if self._ffmpeg_report_path is not None:\n        ffmpeg_log_level = \"info\"\n        logger.info(\"Logging to file: %s\", self._ffmpeg_report_path)\n\n    # Set default FFmpeg parameters for broad compatibility and web optimization\n    # -movflags +faststart enables progressive loading for web playback\n    # Add explicit SDR color tags for predictable playback across platforms\n    ffmpeg_params = [\n        \"-movflags\",\n        \"+faststart\",\n        \"-color_primaries\",\n        \"bt709\",\n        \"-color_trc\",\n        \"bt709\",\n        \"-colorspace\",\n        \"bt709\",\n    ]\n\n    bitrate: Optional[str] = None\n\n    # Codec-specific tuning and quality mapping\n    if ffmpeg_codec in [\"libx264\", \"libx265\"]:\n        # Map quality (0-10) to CRF (35-18)\n        # 10 -&gt; 18 (Excellent), 0 -&gt; 35 (Low quality)\n        # Default to 23 if not specified\n        crf = 18 + (10 - self.quality) * 1.7 if self.quality is not None else 23\n        ffmpeg_params.extend([\"-crf\", f\"{int(crf)}\"])\n        logger.debug(f\"{ffmpeg_codec} tuning: crf={int(crf)}\")\n\n    elif ffmpeg_codec == \"libaom-av1\":\n        # AV1 is extremely slow by default. Use -cpu-used 6 for better speed.\n        # Map 0-10 quality to CRF 50-20 (lower is better)\n        crf = 20 + (10 - self.quality) * 3 if self.quality is not None else 32\n        ffmpeg_params.extend([\"-crf\", f\"{int(crf)}\", \"-cpu-used\", \"6\"])\n        # libaom-av1 needs bitrate=0 to enable CRF mode in FFmpeg\n        bitrate = \"0\"\n        logger.debug(f\"AV1 tuning: crf={int(crf)}, cpu-used=6\")\n\n    elif ffmpeg_codec == \"mpeg4\":\n        # Map quality (0-10) to -q:v (31-2)\n        # Higher -q:v is lower quality.\n        qv = 2 + (10 - self.quality) * 2.9 if self.quality is not None else 4\n        ffmpeg_params.extend([\"-q:v\", f\"{int(qv)}\"])\n        logger.debug(f\"MPEG-4 tuning: q:v={int(qv)}\")\n\n    elif self.bitrate:\n        bitrate = f\"{self.bitrate}k\"\n\n    # Apply final FFmpeg parameters\n    if self._ffmpeg_report_path is not None:\n        ffmpeg_params.extend([\"-report\", \"-loglevel\", \"info\"])\n    try:\n        self._writer = _RawFfmpegPipeWriter(\n            self.output_path,\n            self._adjusted_width,\n            self._adjusted_height,\n            self.fps,\n            ffmpeg_codec,\n            \"rgb24\",\n            \"yuv420p\",\n            ffmpeg_params,\n            ffmpeg_log_level,\n            bitrate,\n        )\n        logger.debug(\n            f\"Initialized FFmpeg pipe writer: {width}x{height} @ {self.fps}fps, \"\n            f\"codec={ffmpeg_codec}, quality={self.quality}, params={ffmpeg_params}\"\n        )\n    except RuntimeError as e:\n        msg = str(e)\n        self._restore_ffmpeg_report_env()\n        if \"ffmpeg\" in msg.lower():\n            raise VideoEncodingError(\n                \"FFmpeg backend not found. Please install imageio-ffmpeg: 'pip install imageio-ffmpeg'\"\n            ) from e\n        raise VideoEncodingError(f\"Failed to initialize video encoder: {e}\") from e\n    except Exception as e:\n        self._restore_ffmpeg_report_env()\n        raise VideoEncodingError(f\"Failed to initialize video encoder: {e}\") from e\n</code></pre>"},{"location":"api/processing/video_encoder/#renderkit.processing.video_encoder.VideoEncoder.is_initialized","title":"<code>is_initialized()</code>","text":"<p>Check if encoder is initialized.</p> Source code in <code>src/renderkit/processing/video_encoder.py</code> <pre><code>def is_initialized(self) -&gt; bool:\n    \"\"\"Check if encoder is initialized.\"\"\"\n    return self._writer is not None\n</code></pre>"},{"location":"api/processing/video_encoder/#renderkit.processing.video_encoder.VideoEncoder.write_frame","title":"<code>write_frame(frame)</code>","text":"<p>Write a frame to the video.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>ndarray</code> <p>Frame as numpy array (H, W, C) in uint8 or float32 format</p> required Source code in <code>src/renderkit/processing/video_encoder.py</code> <pre><code>def write_frame(self, frame: np.ndarray) -&gt; None:\n    \"\"\"Write a frame to the video.\n\n    Args:\n        frame: Frame as numpy array (H, W, C) in uint8 or float32 format\n    \"\"\"\n    if self._writer is None:\n        raise VideoEncodingError(\"Video encoder not initialized. Call initialize() first.\")\n\n    # Resize frame if needed to match adjusted dimensions\n    # This ensures all frames have consistent size for video encoding\n    if frame.shape[1] != self._adjusted_width or frame.shape[0] != self._adjusted_height:\n        frame = ImageScaler.scale_image(\n            frame,\n            width=self._adjusted_width,\n            height=self._adjusted_height,\n            filter_name=\"lanczos3\",\n        )\n\n    # Ensure frame is uint8 [0, 255] for FFmpeg rawvideo\n    if frame.dtype != np.uint8:\n        frame = np.clip(frame * 255.0, 0, 255).astype(np.uint8)\n\n    # FFmpeg rawvideo expects RGB (standard)\n    # If RGBA, drop alpha channel\n    if len(frame.shape) == 3 and frame.shape[2] == 4:\n        frame = frame[:, :, :3]\n    # If Grayscale, ensure 3D\n    elif len(frame.shape) == 2:\n        frame = np.stack([frame] * 3, axis=-1)\n\n    try:\n        self._writer.append_data(frame)\n    except Exception as e:\n        report_tail = self._read_ffmpeg_report_tail()\n        if report_tail:\n            raise VideoEncodingError(\n                f\"Failed to write frame to video: {e}\\n\\n{report_tail}\"\n            ) from e\n        raise VideoEncodingError(f\"Failed to write frame to video: {e}\") from e\n</code></pre>"}]}